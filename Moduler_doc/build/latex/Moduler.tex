% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\floatname{literal-block}{Listing }



\title{Moduler Documentation}
\date{July 24, 2015}
\release{1.0}
\author{Jose Sergio Hleap}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{Intro:introduction}\label{Intro::doc}\label{Intro:welcome-to-moduler-s-documentation}\label{Intro:module-Moduler}\index{Moduler (module)}
\textbf{Moduler Copyright (C) 2012  Jose Sergio Hleap, with contributions of Kyle Nguyen, Alex Safatli and Christian Blouin}

Graph based Modularity.
This script will evaluate the data for modules. Such modules are defined as correlating variables, so the clustering 
is performed in the correlation space. It has an optional statistical significance test for the clustering and power
analysis of the result, as well as a bootstrap analysis. See options for more details.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see \textless{}\href{http://www.gnu.org/licenses/}{http://www.gnu.org/licenses/}\textgreater{}.

E-mail: \href{mailto:jshleap@dal.ca}{jshleap@dal.ca}

In this version the the R dependencies have been extracted, and with them the RV coefficient test.


\section{Requirements:}
\label{Intro:requirements}\begin{enumerate}
\item {} 
numpy module

\item {} 
scipy module

\item {} 
statsmodels module

\item {} 
matplotlib

\item {} 
scikit-learn

\item {} 
PDBnet module: This is an open source module and can be found in :download: \emph{LabBlouinTools\textless{}https://github.com/LabBlouin/LabBlouinTools\textgreater{}}

\end{enumerate}
\begin{quote}

\emph{To install python modules 1-5 in UBUNTU: sudo apt-get install python-\textless{}module\textgreater{} OR  sudo easy\_install -U \textless{}module\textgreater{}  
OR sudo pip install -U \textless{}module\textgreater{}}

\emph{For PDBnet, the whole directory should be downloded into a labblouin folder which should be in your pythonpath}
\end{quote}


\chapter{Tutorial}
\label{Tutorial::doc}\label{Tutorial:tutorial}
Aqui va el turorial que no he realizado todavia


\chapter{Documentation}
\label{Doc:documentation}\label{Doc::doc}\index{GMdata (class in Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMdata}\pysiglinewithargsret{\strong{class }\code{Moduler.}\bfcode{GMdata}}{\emph{prefix}, \emph{dimension=3}, \emph{t='gm'}, \emph{asdistance=False}, \emph{contacts=False}}{}
GM object that populates GM data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} (\emph{string}) -- Prefix of your GM file and accompanying files

\item {} 
\textbf{\texttt{dimension}} (\emph{integer}) -- The number of cartesian dimensions to be analyzed. By default is set to 3.

\item {} 
\textbf{\texttt{t}} (\emph{string}) -- Type of input. Either gm or csv, both semicolon delimited files, but the former includes names of the observations in the first field. By default is gm

\item {} 
\textbf{\texttt{asdistance}} (\emph{boolean}) -- whether or not to tranform the data into a distance matrix

\end{itemize}

\end{description}\end{quote}
\index{Correlated() (Moduler.GMdata method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMdata.Correlated}\pysiglinewithargsret{\bfcode{Correlated}}{\emph{GMstatsInstance}}{}
Include a GMstats instance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{GMstatsInstance}} (\emph{:class GMstats}) -- An instance of the class GMstats

\end{description}\end{quote}

\end{fulllineitems}

\index{Load\_contacts() (Moduler.GMdata method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMdata.Load_contacts}\pysiglinewithargsret{\bfcode{Load\_contacts}}{}{}
Load the contacts from file, from PDBstructure or None

\end{fulllineitems}

\index{Read\_GM() (Moduler.GMdata method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMdata.Read_GM}\pysiglinewithargsret{\bfcode{Read\_GM}}{}{}
Load data from a gm (coordinates file) file. The file is a semicolon separated file
with row names in the first field.

\end{fulllineitems}

\index{bootstrap\_replicate() (Moduler.GMdata method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMdata.bootstrap_replicate}\pysiglinewithargsret{\bfcode{bootstrap\_replicate}}{}{}
Create a bootstrap replicate of the data

\end{fulllineitems}


\end{fulllineitems}

\index{GMstats (class in Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats}\pysiglinewithargsret{\strong{class }\code{Moduler.}\bfcode{GMstats}}{\emph{prefix}, \emph{matrix}, \emph{dimensions}, \emph{sample\_size=None}}{}
Include all stats related things with a GM file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} (\emph{string}) -- Prefix of your GM file and accompanying files

\item {} 
\textbf{\texttt{matrix}} (:class \emph{numpy.array}) -- A numpy nd array with the coordinates or info to be analysed. It contains the dimensions as first element, rows and columns follow.

\item {} 
\textbf{\texttt{dimensions}} (\emph{integer}) -- The number of cartesian dimensions to be analyzed. By default is set to 3.

\item {} 
\textbf{\texttt{sample\_size}} (\emph{integer}) -- Number of observations

\end{itemize}

\end{description}\end{quote}
\index{Clus\_Power() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.Clus_Power}\pysiglinewithargsret{\bfcode{Clus\_Power}}{\emph{membership}}{}
Make a power analysis of the clusters by igraph and outputs a table with the proportion 
of elements above the n required according to significance, power and correlation.
it can test different clusters that are not in the class
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{m}} (\emph{list or string}) -- a membership vector in list form or the name of a file.

\end{description}\end{quote}

\end{fulllineitems}

\index{Compute\_correlations() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.Compute_correlations}\pysiglinewithargsret{\bfcode{Compute\_correlations}}{\emph{method='fisher'}, \emph{absolutecov=False}, \emph{confval=0.95}, \emph{threshold=0.0}, \emph{usecov=False}, \emph{writemat=False}, \emph{additive=True}, \emph{power=0.8}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{method}} (\emph{string}) -- Which method to use for correlation. By default it uses the fisher transformation. Available options are pearson, spearman and fisher.

\item {} 
\textbf{\texttt{confval}} (\emph{float}) -- Define the confidence level (1-alpha) for the correlation test. By default is 0.95. Can take any float value between 0 and 1.

\item {} 
\textbf{\texttt{absolutecov}} (\emph{boolean}) -- Whether or not to use absolute values of the correlation matrix

\item {} 
\textbf{\texttt{power}} (\emph{float}) -- Perform a statistical power analysis with this value as the desired Power (1-type II error). By default 0.8 is used. Can be any float from 0 to 1

\item {} 
\textbf{\texttt{usecov}} (\emph{boolean}) -- Use covariance instead of correlation.

\item {} 
\textbf{\texttt{writemat}} -- Write correlation/covariance matrices to file. By default is false. It can take a False, for the aggreatated matrix or cor for the correlation matrix.

\item {} 
\textbf{\texttt{additive}} (\emph{boolean}) -- Use the mean of the correlation in each dimension instead of the euclidean distance to aglomerate the dimensions. The default behaviour is additive.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{F\_transf() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.F_transf}\pysiglinewithargsret{\bfcode{F\_transf}}{\emph{r}}{}
Compute the Fisher transformation of correlation

\end{fulllineitems}

\index{GetAglomeratedThreshold() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.GetAglomeratedThreshold}\pysiglinewithargsret{\bfcode{GetAglomeratedThreshold}}{}{}
Get threshold for the n dimensions

\end{fulllineitems}

\index{LDA() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.LDA}\pysiglinewithargsret{\bfcode{LDA}}{\emph{membership}, \emph{which='lms'}, \emph{ellipses=2.5}}{}
Perform a Linear discriminant analysis of the transposed data. Membership must be an array
of integers of the same lenght of the number of observations in the data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{membership}} (\emph{list}) -- a list corresponding to memberships of the entries in data

\item {} 
\textbf{\texttt{which}} (\emph{string}) -- Either `gm' or `lms'. To perform the LDA in the full matrix or only in the correlation matrix.

\item {} 
\textbf{\texttt{ellipses}} (\emph{float}) -- A value representing the estandard deviations for confidence ellipses. By default is set to 2.5 (95\% confidence ellipses)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Power\_r() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.Power_r}\pysiglinewithargsret{\bfcode{Power\_r}}{\emph{corr}}{}
Compute the power of the correlation using the Z' trasnformation of correlation coefficient:
Z'=arctang(r)+r/(2*(n-1)) (see Cohen (1988) p.546). 
It will return the required n fo the power and significance chosen.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{corr}} (\emph{float}) -- Correlation value

\end{description}\end{quote}

\end{fulllineitems}

\index{SigCorrOneMatrix() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.SigCorrOneMatrix}\pysiglinewithargsret{\bfcode{SigCorrOneMatrix}}{\emph{sliced}}{}
Performs the significance of correlation test according to the method passed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{sliced}} (:class \emph{numpy.array}) -- an array with single dimensional data

\end{description}\end{quote}

\end{fulllineitems}

\index{Sigcorr() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.Sigcorr}\pysiglinewithargsret{\bfcode{Sigcorr}}{}{}
Test if the correlation is significantly different than 0 with the method specified

\end{fulllineitems}

\index{UseCorr() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.UseCorr}\pysiglinewithargsret{\bfcode{UseCorr}}{}{}
Use pearson correlation without a significant test

\end{fulllineitems}

\index{UseCov() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.UseCov}\pysiglinewithargsret{\bfcode{UseCov}}{}{}
Create a variance-covariance matrix

\end{fulllineitems}

\index{Z\_fisher() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.Z_fisher}\pysiglinewithargsret{\bfcode{Z\_fisher}}{}{}
Compute the sample - corrected Z\_alpha for hypotesis testing of Fisher transformation of correlation

\end{fulllineitems}

\index{agglomerare\_additive() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.agglomerare_additive}\pysiglinewithargsret{\bfcode{agglomerare\_additive}}{}{}
Agglomerate landmark dimensions using euclidean distance

\end{fulllineitems}

\index{agglomerare\_mean() (Moduler.GMstats method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMstats.agglomerare_mean}\pysiglinewithargsret{\bfcode{agglomerare\_mean}}{}{}
Agglomerate landmark dimensions using average of correlation

\end{fulllineitems}


\end{fulllineitems}

\index{GMgraph (class in Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMgraph}\pysiglinewithargsret{\strong{class }\code{Moduler.}\bfcode{GMgraph}}{\emph{prefix}, \emph{Matrix}, \emph{unweighted=False}, \emph{gfilter={[}{]}}, \emph{threshold=0.0}}{}
Create a graph based on an input in matrix form and compute modularity
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{Matrix}} (:class \emph{numpy.array} or :class \emph{GMstats}) -- an square matrix where the indices represent intended nodes and the values the relationship between them

\item {} 
\textbf{\texttt{unweighted}} (\emph{boolean}) -- create an unweighted graph as opposed to a weighted (correlation; default) one.

\item {} 
\textbf{\texttt{gfilter}} (\emph{list of tuples}) -- List of tuples corresponding to desired conection of the graph. Each element in pair tuple must correspond to node indices in the graph. This is a topology constraint.

\item {} 
\textbf{\texttt{threshold}} (\emph{float}) -- A float corresponding to the threshold to create a conection between nodes. This is very user dependendent and is set to 0 as default.

\end{itemize}

\end{description}\end{quote}
\index{Build\_igraph() (Moduler.GMgraph method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMgraph.Build_igraph}\pysiglinewithargsret{\bfcode{Build\_igraph}}{}{}
Build a graph, using igraph library. It will return it, and store it as an attribute (self.g)
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
:class:: `igraph.Graph'

\end{description}\end{quote}

\end{fulllineitems}

\index{Cluster2File() (Moduler.GMgraph method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMgraph.Cluster2File}\pysiglinewithargsret{\bfcode{Cluster2File}}{}{}
Write cluster to a file and rename the cluster with PDB friendly characters if possible (this is specific use)

\end{fulllineitems}

\index{Get\_StructProps() (Moduler.GMgraph method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMgraph.Get_StructProps}\pysiglinewithargsret{\bfcode{Get\_StructProps}}{\emph{overall=False}}{}
Get the structural properties in the graph
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{overall}} (\emph{boolean}) -- Calculate the centralities on the full graph, as opposed as by modules ( Default behaviour ).

\end{description}\end{quote}

\end{fulllineitems}

\index{Graph\_Cluster() (Moduler.GMgraph method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMgraph.Graph_Cluster}\pysiglinewithargsret{\bfcode{Graph\_Cluster}}{\emph{method='fastgreedy'}, \emph{**kwargs}}{}
Clustering by components comstGreed, using igraph library.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{method}} (\emph{string.}) -- method in igraph ofr community detection. It can be fastgreedy, infomap leading\_eigenvector\_naive,leading\_eigenvector,label\_propagation, multilevel, optimal\_modularity, edge\_betweenness, spinglass, walktrap. For details see igraph documentation.

\item {} 
\textbf{\texttt{kwargs}} -- other arguments passed to the igraph methods

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Identify\_Singletons() (Moduler.GMgraph method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMgraph.Identify_Singletons}\pysiglinewithargsret{\bfcode{Identify\_Singletons}}{\emph{method='fastgreedy'}}{}
Given a membership vector identify singletons

\end{fulllineitems}

\index{LDAmerge() (Moduler.GMgraph method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.GMgraph.LDAmerge}\pysiglinewithargsret{\bfcode{LDAmerge}}{\emph{which='lms'}, \emph{ellipses=2.5}, \emph{dimensions=1}}{}
Perform an LDA analisis and merge all classes which 95\% confidence ellipses collide.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{which}} (\emph{string}) -- Either `gm' or `lms'. To perform the LDA in the full matrix or only in the correlation matrix.

\item {} 
\textbf{\texttt{ellipses}} (\emph{float}) -- A value representing the estandard deviations for confidence ellipses. By default is set to 2.5 (95\% confidence ellipses)

\item {} 
\textbf{\texttt{dimensions}} (\emph{integer}) -- dimensions of the matrix

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SupportClustering (class in Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering}\pysiglinewithargsret{\strong{class }\code{Moduler.}\bfcode{SupportClustering}}{\emph{prefix}, \emph{data}, \emph{membership}, \emph{dimensions}, \emph{permutations}, \emph{confval=0.95}, \emph{threshold=0.0}}{}
This class provides ways to provide statistical support for a given clustering scheme. It is based in
testing if the correlation between groups is significatly different than  between groups.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} (\emph{string}) -- a prefix for the output.

\item {} 
\textbf{\texttt{data}} (:class \emph{numpy.ndarray}) -- a 2D numpy array with the data from which the clustering was inferred.

\item {} 
\textbf{\texttt{membership}} (\emph{list}) -- a list equal to the second dimension of data (i.e. data.shape{[}1{]}), corresponding to the clustering scheme being tested.

\item {} 
\textbf{\texttt{dimensions}} (\emph{integer}) -- Number of dimensions in your data matrix. If your matrix is correlation or related, dimesions should be one.

\item {} 
\textbf{\texttt{permutations}} (\emph{integer}) -- Number of permutations to perform the permutation t-test.

\item {} 
\textbf{\texttt{confval}} (\emph{float}) -- confidence value for the test (1 - alpha).

\item {} 
\textbf{\texttt{threshold}} (\emph{float or None}) -- Value to filter out values of the correlation. If set to none, no threshold filtering will be done.

\end{itemize}

\end{description}\end{quote}
\index{AreModneighbours() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.AreModneighbours}\pysiglinewithargsret{\bfcode{AreModneighbours}}{\emph{A}, \emph{indA}, \emph{indB}}{}
loop over the adjacency matrix to find if indA and indB are in the neiborhood
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{A}} (\emph{list}) -- a list of tupples of related entries

\item {} 
\textbf{\texttt{indA}} (\emph{list}) -- indices of grup A

\item {} 
\textbf{\texttt{indB}} (\emph{list}) -- indices of grup B

\end{itemize}

\item[{Returns}] \leavevmode
boolean of whether or not indA and indB are neighbours

\end{description}\end{quote}

\end{fulllineitems}

\index{BipartitionAgree() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.BipartitionAgree}\pysiglinewithargsret{\bfcode{BipartitionAgree}}{\emph{a}, \emph{b}}{}
Return whether 2 strings of bipartitions agree or conflict. The strings must consist of
1 and 0 only
\begin{quote}\begin{description}
\item[{Params a,b}] \leavevmode
binary bipartition strings to be compared for agreements.

\end{description}\end{quote}

\end{fulllineitems}

\index{DealDimensions() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.DealDimensions}\pysiglinewithargsret{\bfcode{DealDimensions}}{}{}
If the data has more than one dimension (in the cartesian sense or the origin of the data),
split it, compute correlation of each dimension and then aggregate it using euclidean distance
of the coefficients of determination. It assumes that the dimensions are interleaved.
This correlation does not have a significance testing, use caution.
It is reccomended to use GMstats class before using this class.

\end{fulllineitems}

\index{FDR\_correction() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.FDR_correction}\pysiglinewithargsret{\bfcode{FDR\_correction}}{}{}
Compute the False Discovery Rate correction for the critical value

\end{fulllineitems}

\index{FDRc\_sigtest() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.FDRc_sigtest}\pysiglinewithargsret{\bfcode{FDRc\_sigtest}}{}{}
Perform the logical significance test using FDR corrected critical value. Returns a binary
dictionary of the comparisons

\end{fulllineitems}

\index{VectorToEdgeList() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.VectorToEdgeList}\pysiglinewithargsret{\bfcode{VectorToEdgeList}}{\emph{v}}{}
Convert a membership vector to a list of edges.
The membership vector must be a list or space separated string.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{v}} (\emph{list}) -- a membership vector in list form

\end{description}\end{quote}

\end{fulllineitems}

\index{WriteBoot() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.WriteBoot}\pysiglinewithargsret{\bfcode{WriteBoot}}{}{}
Write Bootstrap results to screen and file

\end{fulllineitems}

\index{bipartition\_agreement() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.bipartition_agreement}\pysiglinewithargsret{\bfcode{bipartition\_agreement}}{\emph{prefix}}{}
Calculate the local bipartition agreement scores

\end{fulllineitems}

\index{bootstrap() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.bootstrap}\pysiglinewithargsret{\bfcode{bootstrap}}{\emph{boot=0}, \emph{contacts={[}{]}}, \emph{unweighted=False}, \emph{graphmethod='fastgreedy'}, \emph{lda=False}, \emph{iterative=True}, \emph{**kwargs}}{}
Execute the bootstrap inferfence. This boostrap resample obsevations (rows) in the data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{boot}} (\emph{integer}) -- Number of bootstrap replicates to be performed

\item {} 
\textbf{\texttt{contacts}} (\emph{list}) -- filter out non-contact interactions. Contacts passed as list of tuples

\item {} 
\textbf{\texttt{unweighted}} (\emph{boolean}) -- create an unweighted graph as opposed to a weighted (correlation; default) one.

\item {} 
\textbf{\texttt{graphmethod}} -- method in igraph ofr community detection. It can be fastgreedy, infomap leading\_eigenvector\_naive,leading\_eigenvector,label\_propagation, multilevel, optimal\_modularity, edge\_betweenness, spinglass, walktrap. For details see igraph documentation.

\item {} 
\textbf{\texttt{lda}} (\emph{boolean}) -- Use LDA to premerge the community detection clusters

\item {} 
\textbf{\texttt{kwargs}} -- parameter and arguments for GMstats class in the method Compute\_correlations

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{filter\_singletons() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.filter_singletons}\pysiglinewithargsret{\bfcode{filter\_singletons}}{\emph{D}}{}
Giving a dictionary with cluster indices, return whichones are singletons
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{D}} (\emph{dictionary}) -- a dictionary with cluster indices

\item[{Returns}] \leavevmode
a dictionary with the indices of unconnected nodes

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_cluster\_indices() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.get_cluster_indices}\pysiglinewithargsret{\bfcode{get\_cluster\_indices}}{}{}
Returns a dictionary with cluster indices

\end{fulllineitems}

\index{if\_bootfile() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.if_bootfile}\pysiglinewithargsret{\bfcode{if\_bootfile}}{\emph{boot=100}}{}
if another bootsrap intance has been called and crashed, this function will finished
the remaining and / or compute the agreement
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{boot}} (\emph{integer}) -- Number of bootstrap replicates to be performed

\end{description}\end{quote}

\end{fulllineitems}

\index{iterative\_permt() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.iterative_permt}\pysiglinewithargsret{\bfcode{iterative\_permt}}{\emph{filterin}}{}
Perform a permutation test iteratively, until a stable membership vector is reached. In each iteration
a permutation test is performed between the clusters, and a merge event will happen if no evidence of
difference is found.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filterin}} (\emph{list}) -- a list of tuples of pairs of variable to be inlcuded (i.e. adjacency list if mem was provided by a graph)

\end{description}\end{quote}

\end{fulllineitems}

\index{permt() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.permt}\pysiglinewithargsret{\bfcode{permt}}{\emph{filterin}, \emph{count='`}}{}
Perform the permutation test over all pairs of classes in the membership vector provided
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filterin}} (\emph{list}) -- a list of tuples of pairs of variable to be inlcuded (i.e. adjacency list if mem was provided by a graph)

\item {} 
\textbf{\texttt{count}} (\emph{string or integer}) -- Step in which this function has been called. Is for Iterative usage.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{subsetTest() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.subsetTest}\pysiglinewithargsret{\bfcode{subsetTest}}{\emph{k1}, \emph{k2}}{}
Given a series of indices, split the data into intra and inter correlation
and test for equality
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{subsetdata}} -- 

\item {} 
\textbf{\texttt{k1}} (\emph{string or integer}) -- Name of one of the clusters being compared

\item {} 
\textbf{\texttt{k2}} (\emph{string or integer}) -- Name of the other clusters being compared

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{twotPermutation() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.twotPermutation}\pysiglinewithargsret{\bfcode{twotPermutation}}{\emph{x1}, \emph{x2}}{}
This function computes the p-value for the two sample t-test using a permutation test.
This is a translation from the DAAG Package function with the same name.
:param x1: First array (sample) to be compared
:type x1: :class \emph{numpy.ndarray}
:param x2: Second array (sample) to be compared
:type x2: :class \emph{numpy.ndarray}
:param nsim: number of simulations to run ro compute the ovalue
:type nsim: integer

\end{fulllineitems}

\index{write\_permt() (Moduler.SupportClustering method)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.SupportClustering.write_permt}\pysiglinewithargsret{\bfcode{write\_permt}}{\emph{newm}, \emph{count='`}}{}
Write and print the output of the permutation test, the new membership vector, and do some 
cleanup

\end{fulllineitems}


\end{fulllineitems}



\section{Auxiliary methods:}
\label{Doc:auxiliary-methods}\index{isFloat() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.isFloat}\pysiglinewithargsret{\code{Moduler.}\bfcode{isFloat}}{\emph{string}}{}
Auxiliary function to test if a string is a float
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{string}} (\emph{str}) -- The string to be tested

\end{description}\end{quote}

\end{fulllineitems}

\index{rename\_clusters() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.rename_clusters}\pysiglinewithargsret{\code{Moduler.}\bfcode{rename\_clusters}}{\emph{newcl}, \emph{mem}}{}
Rename clusters using the smallest label in each set. Returns the new
membership vector
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{newcl}} (\emph{list}) -- a list with the new membership before renaming

\item {} 
\textbf{\texttt{mem}} (\emph{list}) -- original membership vector

\end{itemize}

\item[{Returns}] \leavevmode
A list with the renamed vector

\end{description}\end{quote}

\end{fulllineitems}

\index{equiclus() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.equiclus}\pysiglinewithargsret{\code{Moduler.}\bfcode{equiclus}}{\emph{merge}}{}
Look for equivalent clusters, and return a list with sets of equivalent clusters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{merge}} (\emph{list}) -- list of tuples with the pairs of classes to be merged

\item[{Returns}] \leavevmode
cleaned membership vector as a list

\end{description}\end{quote}

\end{fulllineitems}

\index{ellipse() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.ellipse}\pysiglinewithargsret{\code{Moduler.}\bfcode{ellipse}}{\emph{singlegroupx}, \emph{singlegroupy}, \emph{std=2.5}}{}
Create an ellipse given points with x coordinates in singlegroupx and singlegroupy
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{singlegroupx}} (:class \emph{numpy.array}) -- An array with the x coordinates of data for what the ellipse is to be built.

\item {} 
\textbf{\texttt{singlegroupy}} (:class \emph{numpy.array}) -- An array with the y coordinates of data for what the ellipse is to be built.

\item {} 
\textbf{\texttt{std}} (\emph{float}) -- The standard deviation of the confidence ellipse. By default is set to 2.5 (95\% confidence ellipse)

\end{itemize}

\item[{Returns}] \leavevmode
a :class \emph{matplotlib.patches.Ellipse} object

\end{description}\end{quote}

\end{fulllineitems}

\index{pointsInEllipse() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.pointsInEllipse}\pysiglinewithargsret{\code{Moduler.}\bfcode{pointsInEllipse}}{\emph{Xs}, \emph{Ys}, \emph{ellipse}}{}
Tests which set of points are within the boundaries defined by the ellipse. The set of points
are defined in two arrays Xs and Ys for the x-coordinates and y-coordinates respectively.
\begin{quote}\begin{description}
\item[{Params Xs}] \leavevmode
x-coordinates of a set of points

\item[{Params Ys}] \leavevmode
y-coordinates of a set of points

\item[{Parameters}] \leavevmode
\textbf{\texttt{ellipse}} (:class \emph{matplotlib.patches.Ellipse}) -- instance of method ellipse

\item[{Returns}] \leavevmode
Tuple of two list, points inside and outside of the ellipse

\end{description}\end{quote}

\end{fulllineitems}

\index{getEllipses() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.getEllipses}\pysiglinewithargsret{\code{Moduler.}\bfcode{getEllipses}}{\emph{fit}, \emph{membership}, \emph{std=2.5}}{}
Populate the ellipses dictionary with as many ellipses as components in membership.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{fit}} (:class \emph{numpy.array}) -- An array normally computed by LDA or other method

\item {} 
\textbf{\texttt{std}} (\emph{float}) -- The standard deviation of the confidence ellipse. By default is set to 2.5 (95\% confidence ellipse)

\item {} 
\textbf{\texttt{membership}} (\emph{list}) -- A list corresponding to memberships of the entries in data.

\end{itemize}

\item[{Returns}] \leavevmode
A dictionary with Ellipse objects with membership as keys.

\end{description}\end{quote}

\end{fulllineitems}

\index{EllipseOverlap() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.EllipseOverlap}\pysiglinewithargsret{\code{Moduler.}\bfcode{EllipseOverlap}}{\emph{ellipse1}, \emph{ellipse2}}{}
Find collisions between ellipses
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ellipse1}} (:class \emph{matplotlib.patches.Ellipse}) -- Matplotlib ellipse

\item {} 
\textbf{\texttt{ellipse2}} (:class \emph{matplotlib.patches.Ellipse}) -- Matplotlib ellipse

\end{itemize}

\item[{Returns}] \leavevmode
Boolean of whether or not two ellipses collide

\end{description}\end{quote}

\end{fulllineitems}

\index{Specificity() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.Specificity}\pysiglinewithargsret{\code{Moduler.}\bfcode{Specificity}}{\emph{ref}, \emph{test}}{}
Compute specificity from two edgelists (list of edges between nodes/labes)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ref}} (\emph{list}) -- Reference edgelist

\item {} 
\textbf{\texttt{test}} (\emph{list}) -- Test edgelist

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Sensitivity() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.Sensitivity}\pysiglinewithargsret{\code{Moduler.}\bfcode{Sensitivity}}{\emph{ref}, \emph{test}}{}
Compute sensitivity from two edgelists (list of edges between nodes/labes)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ref}} (\emph{list}) -- Reference edgelist

\item {} 
\textbf{\texttt{test}} (\emph{list}) -- Test edgelist

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Fscore() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.Fscore}\pysiglinewithargsret{\code{Moduler.}\bfcode{Fscore}}{\emph{sp}, \emph{sn}}{}
Compute the F-score
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{sp}} (\emph{float}) -- Specificity value

\item {} 
\textbf{\texttt{sn}} (\emph{float}) -- Sensitivity value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{clus2list() (in module Moduler)}

\begin{fulllineitems}
\phantomsection\label{Doc:Moduler.clus2list}\pysiglinewithargsret{\code{Moduler.}\bfcode{clus2list}}{\emph{membership}, \emph{data}}{}
Giving a membership vector and data, split the data into cluster specific arrays.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{membership}} (\emph{list or string}) -- a membership vector

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{m}
\item {\texttt{Moduler}}, \pageref{Intro:module-Moduler}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
