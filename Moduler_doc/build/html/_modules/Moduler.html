<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Moduler &mdash; Moduler 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Moduler 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Moduler</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">**Moduler Copyright (C) 2012  Jose Sergio Hleap, with contributions of Kyle Nguyen, Alex Safatli and Christian Blouin**</span>

<span class="sd">Graph based Modularity.</span>
<span class="sd">This script will evaluate the data for modules. Such modules are defined as correlating variables, so the clustering </span>
<span class="sd">is performed in the correlation space. It has an optional statistical significance test for the clustering and power</span>
<span class="sd">analysis of the result, as well as a bootstrap analysis. See options for more details.</span>


<span class="sd">This program is free software: you can redistribute it and/or modify</span>
<span class="sd">it under the terms of the GNU General Public License as published by</span>
<span class="sd">the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">(at your option) any later version.</span>

<span class="sd">This program is distributed in the hope that it will be useful,</span>
<span class="sd">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">GNU General Public License for more details.</span>

<span class="sd">You should have received a copy of the GNU General Public License</span>
<span class="sd">along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="sd">E-mail: jshleap@dal.ca</span>


<span class="sd">In this version the the R dependencies have been extracted, and with them the RV coefficient test.</span>

<span class="sd">Requirements:</span>
<span class="sd">=============</span>

<span class="sd">1. numpy module</span>
<span class="sd">2. scipy module</span>
<span class="sd">3. statsmodels module</span>
<span class="sd">4. matplotlib</span>
<span class="sd">5. scikit-learn   </span>
<span class="sd">6. PDBnet module: This is an open source module and can be found in :download: `LabBlouinTools&lt;https://github.com/LabBlouin/LabBlouinTools&gt;`</span>
<span class="sd"> </span>
<span class="sd"> *To install python modules 1-5 in UBUNTU: sudo apt-get install python-&lt;module&gt;	OR  sudo easy_install -U &lt;module&gt;  </span>
<span class="sd"> OR sudo pip install -U &lt;module&gt;*</span>
<span class="sd"> </span>
<span class="sd"> *For PDBnet, the whole directory should be downloded into a labblouin folder which should be in your pythonpath*</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__author__</span>        <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Jose Sergio Hleap&#39;</span><span class="p">,]</span>
<span class="n">__contributions__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Kyle Nguyen&#39;</span><span class="p">,</span> <span class="s">&#39;Alex Safatli&#39;</span><span class="p">,</span> <span class="s">&#39;Christian Blouin&#39;</span><span class="p">]</span>
<span class="n">__version__</span>       <span class="o">=</span> <span class="mf">1.0</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">corrcoef</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">savetxt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">column_stack</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">isnan</span><span class="p">,</span> <span class="n">rad2deg</span><span class="p">,</span> <span class="n">arccos</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">triu_indices</span><span class="p">,</span> <span class="n">percentile</span><span class="p">,</span> <span class="n">arctanh</span><span class="p">,</span> <span class="n">triu</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span><span class="p">,</span> <span class="n">kendalltau</span><span class="p">,</span> <span class="n">spearmanr</span><span class="p">,</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">labblouin.PDBnet</span> <span class="kn">import</span> <span class="n">PDBstructure</span> <span class="k">as</span> <span class="n">P</span>
<span class="kn">from</span> <span class="nn">igraph</span> <span class="kn">import</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">VertexClustering</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">isfile</span><span class="p">,</span><span class="n">dirname</span><span class="p">,</span><span class="n">join</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Ellipse</span>
<span class="kn">import</span> <span class="nn">statsmodels.stats.power</span> <span class="kn">as</span> <span class="nn">smp</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">eig</span><span class="p">,</span> <span class="n">pinv</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">choice</span>
<span class="kn">from</span> <span class="nn">sklearn.lda</span> <span class="kn">import</span> <span class="n">LDA</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">sample</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">rename</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">import</span> <span class="nn">optparse</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">pickle</span>


<span class="n">__licence__</span>       <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">),</span><span class="s">&#39;gpl.txt&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="c"># main classes</span>
<div class="viewcode-block" id="GMdata"><a class="viewcode-back" href="../Doc.html#Moduler.GMdata">[docs]</a><span class="k">class</span> <span class="nc">GMdata</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">	GM object that populates GM data</span>

<span class="sd">	:param prefix: Prefix of your GM file and accompanying files</span>
<span class="sd">	:type prefix: string</span>
<span class="sd">	:param dimension: The number of cartesian dimensions to be analyzed. By default is set to 3.</span>
<span class="sd">	:type dimension: integer</span>
<span class="sd">	:param t: Type of input. Either gm or csv, both semicolon delimited files, but the former includes names of the observations in the first field. By default is gm</span>
<span class="sd">	:type t: string</span>
<span class="sd">	:param asdistance: whether or not to tranform the data into a distance matrix</span>
<span class="sd">	:type asdistance: boolean</span>
<span class="sd">	&#39;&#39;&#39;</span>	
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s">&#39;gm&#39;</span><span class="p">,</span><span class="n">asdistance</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">contacts</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dimension</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">t</span>

		<span class="c"># read file</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">Read_GM</span><span class="p">()</span>
		<span class="c"># transform to distance?</span>
		<span class="k">if</span> <span class="n">asdistance</span><span class="p">:</span>
			<span class="n">asdistance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">contacts</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">Load_contacts</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="bp">False</span>


<div class="viewcode-block" id="GMdata.Read_GM"><a class="viewcode-back" href="../Doc.html#Moduler.GMdata.Read_GM">[docs]</a>	<span class="k">def</span> <span class="nf">Read_GM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Load data from a gm (coordinates file) file. The file is a semicolon separated file</span>
<span class="sd">		with row names in the first field.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="c"># Load Data ##########################################################</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">sample_size</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="c"># line for each dimension and create slush temp lists</span>
		<span class="n">temps</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
			<span class="n">temps</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
			<span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
		<span class="c"># Set the filename with the proper suffix</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&#39;csv&#39;</span><span class="p">:</span>
			<span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.csv&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.gm&#39;</span>
		<span class="c"># Open file and read each line</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">F</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">F</span><span class="p">:</span>
				<span class="c">#get the names</span>
				<span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>            				
				<span class="c"># Split into list</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&#39;gm&#39;</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;;&#39;</span><span class="p">:</span>
						<span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
				<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s">&#39;csv&#39;</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;;&#39;</span><span class="p">:</span>
						<span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;;&#39;</span><span class="p">)</span>

				<span class="c"># check if there is a titleline</span>
				<span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">isFloat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]):</span>
					<span class="k">continue</span>
				<span class="c"># Dispatch values in the right dimension list using i%dim to index</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
					<span class="n">temps</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
				<span class="c"># Grow each matrix by 1 row</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temps</span><span class="p">)):</span>
					<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="n">sample_size</span> <span class="o">+=</span> <span class="mi">1</span> 
				<span class="c"># Flush temps </span>
				<span class="n">temps</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
					<span class="n">temps</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span> <span class="o">=</span> <span class="n">sample_size</span>    
		<span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span><span class="n">labels</span>
</div>
<div class="viewcode-block" id="GMdata.bootstrap_replicate"><a class="viewcode-back" href="../Doc.html#Moduler.GMdata.bootstrap_replicate">[docs]</a>	<span class="k">def</span> <span class="nf">bootstrap_replicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Create a bootstrap replicate of the data</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">ch</span>   <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
			<span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">ch</span><span class="p">,:])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">boot</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">boot</span>
</div>
<div class="viewcode-block" id="GMdata.Load_contacts"><a class="viewcode-back" href="../Doc.html#Moduler.GMdata.Load_contacts">[docs]</a>	<span class="k">def</span> <span class="nf">Load_contacts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Load the contacts from file, from PDBstructure or None</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="o">=</span><span class="p">[]</span>
		<span class="n">fn</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">.contacts&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
			<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">as</span> <span class="n">F</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">F</span><span class="p">:</span>
					<span class="n">l</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
		<span class="k">elif</span> <span class="n">isfile</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.pdb&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)):</span>
			<span class="n">pdb</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.pdb&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="n">pdb</span><span class="o">.</span><span class="n">Contacts</span><span class="p">(</span><span class="n">fasta</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.fasta&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">pdb</span> <span class="o">=</span> <span class="n">pdb</span>
			<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.contacts&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">F</span><span class="p">:</span> <span class="p">[</span><span class="n">F</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;No Contact file nor PDB file provided&#39;</span><span class="p">)</span>
			</div>
<div class="viewcode-block" id="GMdata.Correlated"><a class="viewcode-back" href="../Doc.html#Moduler.GMdata.Correlated">[docs]</a>	<span class="k">def</span> <span class="nf">Correlated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">GMstatsInstance</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Include a GMstats instance</span>

<span class="sd">		:param GMstatsInstance: An instance of the class GMstats</span>
<span class="sd">		:type GMstatsInstance: :class GMstats</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">GMstats</span> <span class="o">=</span> <span class="n">GMstatsInstance</span>


<span class="c">###############################################################################################</span></div></div>
<div class="viewcode-block" id="GMstats"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats">[docs]</a><span class="k">class</span> <span class="nc">GMstats</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">	Include all stats related things with a GM file</span>
<span class="sd">	</span>
<span class="sd">	:param prefix: Prefix of your GM file and accompanying files</span>
<span class="sd">	:type prefix: string</span>
<span class="sd">	:param matrix: A numpy nd array with the coordinates or info to be analysed. It contains the dimensions as first element, rows and columns follow.</span>
<span class="sd">	:type matrix: :class `numpy.array`</span>
<span class="sd">	:param dimensions: The number of cartesian dimensions to be analyzed. By default is set to 3.</span>
<span class="sd">	:type dimensions: integer</span>
<span class="sd">	:param sample_size: Number of observations</span>
<span class="sd">	:type sample_size: integer</span>
<span class="sd">	&#39;&#39;&#39;</span>	
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prefix</span><span class="p">,</span><span class="n">matrix</span><span class="p">,</span><span class="n">dimensions</span><span class="p">,</span><span class="n">sample_size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">data</span>   <span class="o">=</span> <span class="n">matrix</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dim</span>    <span class="o">=</span> <span class="n">dimensions</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">lms</span>    <span class="o">=</span> <span class="bp">None</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">sample_size</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">=</span> <span class="n">sample_size</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">Compute_correlations</span><span class="p">()</span>


<div class="viewcode-block" id="GMstats.Compute_correlations"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.Compute_correlations">[docs]</a>	<span class="k">def</span> <span class="nf">Compute_correlations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;fisher&#39;</span><span class="p">,</span><span class="n">absolutecov</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">confval</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">usecov</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
	                         <span class="n">writemat</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">additive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">power</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		:param method: Which method to use for correlation. By default it uses the fisher transformation. Available options are pearson, spearman and fisher.        </span>
<span class="sd">		:type method: string</span>
<span class="sd">		:param confval: Define the confidence level (1-alpha) for the correlation test. By default is 0.95. Can take any float value between 0 and 1.</span>
<span class="sd">		:type confval: float</span>
<span class="sd">		:param absolutecov: Whether or not to use absolute values of the correlation matrix</span>
<span class="sd">		:type absolutecov: boolean</span>
<span class="sd">		:param power: Perform a statistical power analysis with this value as the desired Power (1-type II error). By default 0.8 is used. Can be any float from 0 to 1</span>
<span class="sd">		:type power: float</span>
<span class="sd">		:param usecov: Use covariance instead of correlation.</span>
<span class="sd">		:type usecov: boolean</span>
<span class="sd">		:param writemat: Write correlation/covariance matrices to file. By default is false. It can take a False, for the aggreatated matrix or cor for the correlation matrix.</span>
<span class="sd">		:param additive: Use the mean of the correlation in each dimension instead of the euclidean distance to aglomerate the dimensions. The default behaviour is additive.</span>
<span class="sd">		:type additive: boolean</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">method</span>      <span class="o">=</span> <span class="n">method</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">confval</span>     <span class="o">=</span> <span class="n">confval</span> 
		<span class="bp">self</span><span class="o">.</span><span class="n">absolutecov</span> <span class="o">=</span> <span class="n">absolutecov</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">power</span>       <span class="o">=</span> <span class="n">power</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">threshold</span>   <span class="o">=</span> <span class="n">threshold</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">usecov</span>      <span class="o">=</span> <span class="n">usecov</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">writemat</span>    <span class="o">=</span> <span class="n">writemat</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">additive</span>    <span class="o">=</span> <span class="n">additive</span>
		<span class="n">thr</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c"># Create a correlation matrix testing for significance #################</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">Sigcorr</span><span class="p">()</span>
		<span class="c"># Else, use covariance matrix instead or correlation without statistical</span>
		<span class="c"># test #################################################################</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">usecov</span><span class="p">:</span>
			<span class="n">thr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">UseCov</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">thr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">UseCorr</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices</span>
		<span class="k">if</span> <span class="n">mat</span> <span class="o">==</span> <span class="s">&#39;cor&#39;</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">)):</span>
				<span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;.mat&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">m</span><span class="p">],</span><span class="n">delimiter</span><span class="o">=</span><span class="s">&#39;;&#39;</span><span class="p">,</span><span class="n">fmt</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">)</span>

		<span class="c"># Agglomerate landmark dimensions ######################################</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additive</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">agglomerare_additive</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">agglomerare_mean</span><span class="p">()</span>

		<span class="k">if</span> <span class="n">mat</span> <span class="o">==</span> <span class="s">&#39;agg&#39;</span><span class="p">:</span>
			<span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.lms&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s">&#39;;&#39;</span><span class="p">,</span><span class="n">fmt</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">)</span>		

</div>
<div class="viewcode-block" id="GMstats.agglomerare_additive"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.agglomerare_additive">[docs]</a>	<span class="k">def</span> <span class="nf">agglomerare_additive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Agglomerate landmark dimensions using euclidean distance</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">lms</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
				<span class="n">sm</span> <span class="o">=</span> <span class="mf">0.0</span>
				<span class="c"># Sum over all dimensions</span>
				<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">:</span>
					<span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolutecov</span><span class="p">:</span>
						<span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
					<span class="n">sm</span> <span class="o">+=</span> <span class="p">(</span><span class="n">d</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
				<span class="n">sq</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span>
				<span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sq</span><span class="p">)</span>
			<span class="n">lms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>	

		<span class="bp">self</span><span class="o">.</span><span class="n">lms</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">lms</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GMstats.agglomerare_mean"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.agglomerare_mean">[docs]</a>	<span class="k">def</span> <span class="nf">agglomerare_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;Agglomerate landmark dimensions using average of correlation	&#39;&#39;&#39;</span>
		<span class="n">lms</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
				<span class="n">sm</span> <span class="o">=</span> <span class="mf">0.0</span>
				<span class="c"># Sum over all dimensions</span>
				<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">:</span>
					<span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolutecov</span><span class="p">:</span>
						<span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
					<span class="n">sm</span> <span class="o">+=</span> <span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

				<span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sm</span><span class="p">)</span>
			<span class="n">lms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>	

		<span class="bp">self</span><span class="o">.</span><span class="n">lms</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">lms</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GMstats.Sigcorr"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.Sigcorr">[docs]</a>	<span class="k">def</span> <span class="nf">Sigcorr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Test if the correlation is significantly different than 0 with the method specified</span>
<span class="sd">		&#39;&#39;&#39;</span>     
		<span class="bp">self</span><span class="o">.</span><span class="n">matrices</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
			<span class="c"># Perform the significant correlation test in each dimension</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SigCorrOneMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

</div>
<div class="viewcode-block" id="GMstats.SigCorrOneMatrix"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.SigCorrOneMatrix">[docs]</a>	<span class="k">def</span> <span class="nf">SigCorrOneMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sliced</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Performs the significance of correlation test according to the method passed</span>
<span class="sd">		</span>
<span class="sd">		:param sliced: an array with single dimensional data</span>
<span class="sd">		:type sliced: :class `numpy.array`</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">sliced</span>
		<span class="c"># Get a matrix of zeroes.</span>
		<span class="n">zero</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

		<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">)):</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;pearson&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;fisher&#39;</span><span class="p">:</span>
					<span class="n">p</span><span class="o">=</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">f</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;kendall&#39;</span><span class="p">:</span>
					<span class="n">p</span><span class="o">=</span><span class="n">kendalltau</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">f</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;spearman&#39;</span><span class="p">:</span>
					<span class="n">p</span><span class="o">=</span><span class="n">spearmanr</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">f</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>					

				<span class="c"># Symmetrize	</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;fisher&#39;</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
						<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.999</span><span class="p">,</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolutecov</span><span class="p">:</span>
						<span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F_transf</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_fisher</span><span class="p">()</span>\
						   <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Power_r</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
							<span class="n">zero</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
						<span class="k">else</span><span class="p">:</span>
							<span class="n">zero</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

					<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_transf</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z_fisher</span><span class="p">()</span>\
					     <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Power_r</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
						<span class="n">zero</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">zero</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Power_r</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
						<span class="n">zero</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
					<span class="k">else</span><span class="p">:</span>
						<span class="n">zero</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="k">return</span> <span class="n">zero</span>	
</div>
<div class="viewcode-block" id="GMstats.F_transf"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.F_transf">[docs]</a>	<span class="k">def</span> <span class="nf">F_transf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Compute the Fisher transformation of correlation</span>
<span class="sd">		&#39;&#39;&#39;</span>	
		<span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">log</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">r</span><span class="p">)))</span>
</div>
<div class="viewcode-block" id="GMstats.Z_fisher"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.Z_fisher">[docs]</a>	<span class="k">def</span> <span class="nf">Z_fisher</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Compute the sample - corrected Z_alpha for hypotesis testing of Fisher transformation of correlation</span>
<span class="sd">		&#39;&#39;&#39;</span>		
		<span class="n">confval</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">norm</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">confval</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="GMstats.Power_r"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.Power_r">[docs]</a>	<span class="k">def</span> <span class="nf">Power_r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corr</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Compute the power of the correlation using the Z&#39; trasnformation of correlation coefficient:</span>
<span class="sd">		Z&#39;=arctang(r)+r/(2*(n-1)) (see Cohen (1988) p.546). </span>
<span class="sd">		It will return the required n fo the power and significance chosen.</span>
<span class="sd">		</span>
<span class="sd">		:param corr: Correlation value</span>
<span class="sd">		:type corr: float</span>
<span class="sd">		&#39;&#39;&#39;</span>

		<span class="k">if</span> <span class="n">corr</span>  <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">corr</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">and</span> <span class="n">corr</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">0.001</span><span class="p">)</span> <span class="p">:</span>
			<span class="n">corr</span> <span class="o">=</span> <span class="mf">0.0012</span>
		<span class="k">elif</span> <span class="n">corr</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.001</span><span class="p">:</span>
			<span class="n">corr</span> <span class="o">=</span>  <span class="n">corr</span>
		<span class="k">elif</span> <span class="n">corr</span> <span class="o">&gt;=</span> <span class="mf">0.99</span><span class="p">:</span>
			<span class="n">corr</span> <span class="o">=</span>  <span class="mf">0.99</span>			
		<span class="k">else</span><span class="p">:</span>
			<span class="n">corr</span> <span class="o">=</span> <span class="n">corr</span>	
		<span class="sd">&#39;&#39;&#39;		</span>
<span class="sd">		r(&#39;p=pwr.r.test(power=%f,r=%f, sig.level=%f)&#39;%(float(self.power), float(corr), float(1-self.confval)))</span>
<span class="sd">		n = r(&#39;p[1]&#39;)[0]</span>
<span class="sd">		if this part is reverted:</span>
<span class="sd">		Require the R package PWR written by Stephane Champely &lt;champely@univ-lyon1.fr&gt;. </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="c">#This is in beta to avoid dependencies outside python</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">smp</span><span class="o">.</span><span class="n">NormalIndPower</span><span class="p">()</span><span class="o">.</span><span class="n">solve_power</span><span class="p">(</span><span class="n">arctanh</span><span class="p">(</span><span class="n">corr</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span><span class="p">),</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
		                                     <span class="n">power</span><span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">),</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;two-sided&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>		

		<span class="k">return</span> <span class="n">n</span>	
</div>
<div class="viewcode-block" id="GMstats.UseCov"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.UseCov">[docs]</a>	<span class="k">def</span> <span class="nf">UseCov</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Create a variance-covariance matrix</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">thr</span><span class="o">=</span><span class="p">[]</span>
		<span class="c"># Perform np magic</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
			<span class="n">l</span><span class="o">=</span><span class="mi">88</span>
			<span class="c"># Convert to np matrix</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">l</span><span class="o">+=</span><span class="n">i</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cov</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">==</span> <span class="s">&#39;Auto&#39;</span><span class="p">:</span>
				<span class="c">#get the threshold from correlation matrix#</span>
				<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
					<span class="n">thr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">]))</span>
		<span class="k">return</span> <span class="n">thr</span>
</div>
<div class="viewcode-block" id="GMstats.UseCorr"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.UseCorr">[docs]</a>	<span class="k">def</span> <span class="nf">UseCorr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Use pearson correlation without a significant test</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">thr</span><span class="o">=</span><span class="p">[]</span>
		<span class="c"># Perform np magic</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
			<span class="n">l</span><span class="o">=</span><span class="mi">88</span>
			<span class="c"># Convert to np matrix</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">l</span><span class="o">+=</span><span class="n">i</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">==</span> <span class="s">&#39;Auto&#39;</span><span class="p">:</span>
				<span class="c">#get the threshold from correlation matrix#</span>
				<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
					<span class="n">thr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">]))</span>	
		<span class="k">return</span> <span class="n">thr</span>

</div>
<div class="viewcode-block" id="GMstats.GetAglomeratedThreshold"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.GetAglomeratedThreshold">[docs]</a>	<span class="k">def</span> <span class="nf">GetAglomeratedThreshold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; Get threshold for the n dimensions&#39;&#39;&#39;</span>
		<span class="c"># Call if you need to get the vector of threshold</span>
		<span class="n">thr</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">i</span> <span class="o">!=</span><span class="n">j</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.00000</span><span class="p">:</span>
					<span class="n">thr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
		<span class="n">threshold</span> <span class="o">=</span> <span class="n">std</span><span class="p">(</span><span class="n">thr</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span> 

</div>
<div class="viewcode-block" id="GMstats.LDA"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.LDA">[docs]</a>	<span class="k">def</span> <span class="nf">LDA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">membership</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s">&#39;lms&#39;</span><span class="p">,</span> <span class="n">ellipses</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Perform a Linear discriminant analysis of the transposed data. Membership must be an array</span>
<span class="sd">		of integers of the same lenght of the number of observations in the data. </span>

<span class="sd">		:param membership: a list corresponding to memberships of the entries in data</span>
<span class="sd">		:type membership: list</span>
<span class="sd">		:param which: Either &#39;gm&#39; or &#39;lms&#39;. To perform the LDA in the full matrix or only in the correlation matrix.</span>
<span class="sd">		:type which: string</span>
<span class="sd">		:param ellipses: A value representing the estandard deviations for confidence ellipses. By default is set to 2.5 (95% confidence ellipses)</span>
<span class="sd">		:type ellipses: float</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="n">which</span> <span class="o">==</span> <span class="s">&#39;gm&#39;</span><span class="p">:</span> 
			<span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
				<span class="n">membership</span> <span class="o">=</span> <span class="n">membership</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">data</span> <span class="o">=</span> <span class="n">column_stack</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]))</span>
			<span class="k">elif</span> <span class="nb">any</span><span class="p">(((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">membership</span><span class="p">)),</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">membership</span><span class="p">)))):</span>
				<span class="n">m</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">membership</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">membership</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">membership</span><span class="p">))]</span>
		<span class="k">else</span><span class="p">:</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span>

		<span class="n">membership</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">membership</span><span class="p">)</span>
		<span class="c">#dont include singletons</span>
		<span class="n">nonsingles</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">membership</span> <span class="o">!=</span> <span class="s">&#39;?&#39;</span><span class="p">)</span>
		<span class="n">membership</span> <span class="o">=</span> <span class="n">membership</span><span class="p">[</span><span class="n">nonsingles</span><span class="p">]</span>
		<span class="n">data</span>       <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">nonsingles</span><span class="p">]</span>
		<span class="n">lda</span> <span class="o">=</span> <span class="n">LDA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">fit</span> <span class="o">=</span> <span class="n">lda</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">membership</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">ellipses</span><span class="p">:</span>
			<span class="n">ell</span> <span class="o">=</span> <span class="n">getEllipses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">,</span> <span class="n">membership</span><span class="p">,</span><span class="n">ellipses</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="GMstats.Clus_Power"><a class="viewcode-back" href="../Doc.html#Moduler.GMstats.Clus_Power">[docs]</a>	<span class="k">def</span> <span class="nf">Clus_Power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">membership</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Make a power analysis of the clusters by igraph and outputs a table with the proportion </span>
<span class="sd">		of elements above the n required according to significance, power and correlation.</span>
<span class="sd">		it can test different clusters that are not in the class</span>

<span class="sd">		:param m: a membership vector in list form or the name of a file.</span>
<span class="sd">		:type m: list or string</span>

<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">membership</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> <span class="n">mem</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.graphcluster&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">membership</span>
		<span class="c"># alternative dictionary</span>
		<span class="n">proportion</span><span class="o">=</span><span class="p">{}</span>
		<span class="c"># Split the data into the clusters ignoring singletons. This assumes that singletons have </span>
		<span class="c"># been identifed</span>
		<span class="n">darr</span> <span class="o">=</span> <span class="n">clus2list</span><span class="p">(</span><span class="n">membership</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">matrices</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">darr</span><span class="p">:</span>
			<span class="c"># get all outputs</span>
			<span class="n">resline</span> <span class="o">=</span> <span class="s">&#39;#################################################################</span><span class="se">\n</span><span class="s">&#39;</span>
			<span class="n">resline</span><span class="o">+=</span> <span class="s">&#39;#Power analysis and description of the intracluster correlation:#</span><span class="se">\n</span><span class="s">&#39;</span>
			<span class="n">resline</span><span class="o">+=</span> <span class="s">&#39;#################################################################</span><span class="se">\n\n</span><span class="s">&#39;</span>
			<span class="n">resline</span><span class="o">+=</span> <span class="s">&#39;1 - Significance(alpha)= </span><span class="si">%f</span><span class="s">;</span><span class="se">\t</span><span class="s">1 - Power(beta):</span><span class="si">%f</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">power</span><span class="p">)</span>
			<span class="n">resline</span><span class="o">+=</span> <span class="s">&#39;Sample Size : </span><span class="si">%d</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
			<span class="c">#loop over clusters</span>
			<span class="k">for</span> <span class="n">clusters</span> <span class="ow">in</span> <span class="n">darr</span><span class="p">:</span>
				<span class="n">c</span><span class="o">=</span><span class="n">darr</span><span class="p">[</span><span class="n">clusters</span><span class="p">]</span>
				<span class="c"># if is a list of n dimensions zip each correlation and return the max</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span> <span class="n">c</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)])</span>
				<span class="c"># estimate quantiles</span>
				<span class="n">q</span> <span class="o">=</span> <span class="n">percentile</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">75</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
				<span class="c"># estimate the proportion of variables with enough power</span>
				<span class="n">enough</span><span class="o">=</span><span class="mf">0.0</span>
				<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
					<span class="n">nsam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Power_r</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
					<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsam</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
						<span class="n">enough</span> <span class="o">+=</span> <span class="mf">1.0</span>
				<span class="n">prop</span> <span class="o">=</span> <span class="n">enough</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
				<span class="n">tr</span> <span class="o">=</span> <span class="s">&#39; 0% </span><span class="se">\t\t</span><span class="s"> 25% </span><span class="se">\t\t</span><span class="s"> 50% </span><span class="se">\t\t</span><span class="s"> 75% </span><span class="se">\t\t</span><span class="s"> 100% </span><span class="se">\t\t</span><span class="s"> PVP </span><span class="se">\t\t</span><span class="s"> nvar </span><span class="se">\n</span><span class="s">&#39;</span>
				<span class="n">resline</span><span class="o">+=</span> <span class="n">tr</span> <span class="o">+</span><span class="s">&#39; </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%f</span><span class="s"> </span><span class="se">\t</span><span class="s"> </span><span class="si">%d</span><span class="s">/</span><span class="si">%d</span><span class="s"> </span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="nb">round</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span>
				                                                                 <span class="nb">round</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="nb">round</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="nb">round</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span>
				                                                                 <span class="nb">round</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">enough</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
				<span class="n">proportion</span><span class="p">[</span><span class="n">clusters</span><span class="p">]</span><span class="o">=</span><span class="n">prop</span>
			<span class="n">resline</span><span class="o">+=</span> <span class="s">&#39;_&#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
			<span class="n">resline</span><span class="o">+=</span> <span class="s">&#39;Percentages are the quantiles of the lower triangle of the correlation matrix</span><span class="se">\n</span><span class="s">&#39;</span>
			<span class="n">resline</span><span class="o">+=</span> <span class="s">&#39;PVP: Proportion of variables with enough statistical power </span><span class="se">\n</span><span class="s">&#39;</span>
			<span class="n">resline</span><span class="o">+=</span> <span class="s">&#39;nvar: Number of variables with enough power within the cluster </span><span class="se">\n</span><span class="s">&#39;</span>
			<span class="c"># Open the output file and write resline</span>
			<span class="c"># write to file</span>
			<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_Power_analysis.asc&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">),</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ouf</span><span class="p">:</span>
				<span class="n">ouf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">resline</span><span class="p">)</span>
			<span class="k">print</span> <span class="n">resline</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">print</span> <span class="s">&#39;Only singletons in the dataset. Either correlation zero or not enough power to resolve&#39;</span>\
			      <span class="s">&#39;a negligible correlation.&#39;</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">PVP</span> <span class="o">=</span> <span class="n">proportion</span>
		<span class="k">return</span> <span class="n">proportion</span>	

<span class="c">###############################################################################################</span></div></div>
<div class="viewcode-block" id="GMgraph"><a class="viewcode-back" href="../Doc.html#Moduler.GMgraph">[docs]</a><span class="k">class</span> <span class="nc">GMgraph</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">	Create a graph based on an input in matrix form and compute modularity</span>
<span class="sd">	</span>
<span class="sd">	:param Matrix: an square matrix where the indices represent intended nodes and the values the relationship between them</span>
<span class="sd">	:type Matrix: :class `numpy.array` or :class `GMstats`</span>
<span class="sd">	:param unweighted: create an unweighted graph as opposed to a weighted (correlation; default) one.</span>
<span class="sd">	:type unweighted: boolean</span>
<span class="sd">	:param gfilter: List of tuples corresponding to desired conection of the graph. Each element in pair tuple must correspond to node indices in the graph. This is a topology constraint.</span>
<span class="sd">	:type gfilter: list of tuples</span>
<span class="sd">	:param threshold: A float corresponding to the threshold to create a conection between nodes. This is very user dependendent and is set to 0 as default.</span>
<span class="sd">	:type threshold: float</span>
<span class="sd">	&#39;&#39;&#39;</span>	
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">unweighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">gfilter</span><span class="o">=</span><span class="p">[],</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
		
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Matrix</span><span class="p">,</span><span class="n">GMstats</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span> <span class="o">=</span> <span class="n">Matrix</span><span class="o">.</span><span class="n">lms</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmstats</span><span class="o">=</span><span class="n">Matrix</span>
		<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span> <span class="o">=</span> <span class="n">Matrix</span> <span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmstats</span> <span class="o">=</span> <span class="bp">False</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">gfilter</span>   <span class="o">=</span> <span class="n">gfilter</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">unweighted</span><span class="o">=</span> <span class="n">unweighted</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">prefix</span>    <span class="o">=</span> <span class="n">prefix</span>

		<span class="c">#check if graph have been done before if so load it is not execute buildgraph</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">+</span> <span class="s">&#39;.igraph.pickl&#39;</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">Build_igraph</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s">&#39;.igraph.pickl&#39;</span><span class="p">))</span>

<div class="viewcode-block" id="GMgraph.Build_igraph"><a class="viewcode-back" href="../Doc.html#Moduler.GMgraph.Build_igraph">[docs]</a>	<span class="k">def</span> <span class="nf">Build_igraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Build a graph, using igraph library. It will return it, and store it as an attribute (self.g)</span>
<span class="sd">		</span>
<span class="sd">		:returns: :class:: &#39;igraph.Graph&#39; </span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="c"># create a multiplier if the weights are not high enough for resolution</span>
		<span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">/</span><span class="mf">100000.</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-4</span><span class="p">:</span> <span class="n">multiplier</span> <span class="o">=</span> <span class="mi">100000</span>
		<span class="k">else</span><span class="p">:</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">1</span>

		<span class="n">g</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">))</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">)):</span>
			<span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">)):</span>
				<span class="c">#Assign edges if value is over the threshold</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
					<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gfilter</span><span class="p">:</span>
						<span class="c">#Only add edges if not filtered out</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gfilter</span><span class="p">:</span>
							<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
							<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unweighted</span><span class="p">:</span><span class="c">##if unweighted, don&#39;t include weight</span>
								<span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;wts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">multiplier</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
						<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unweighted</span><span class="p">:</span><span class="c">##if unweighted, don&#39;t include weight</span>
							<span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s">&#39;wts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">multiplier</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
		<span class="n">g</span><span class="o">.</span><span class="n">write_pickle</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">+</span> <span class="s">&#39;.igraph.pickl&#39;</span><span class="p">)</span>
		<span class="n">g</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.edges&#39;</span><span class="p">)</span>		
		<span class="k">return</span> <span class="n">g</span>
</div>
<div class="viewcode-block" id="GMgraph.Get_StructProps"><a class="viewcode-back" href="../Doc.html#Moduler.GMgraph.Get_StructProps">[docs]</a>	<span class="k">def</span> <span class="nf">Get_StructProps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">overall</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		Get the structural properties in the graph</span>

<span class="sd">		:param overall: Calculate the centralities on the full graph, as opposed as by modules ( Default behaviour ).</span>
<span class="sd">		:type overall: boolean</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unweighted</span><span class="p">:</span> <span class="n">weights</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="k">else</span><span class="p">:</span> <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s">&#39;wts&#39;</span><span class="p">]</span>

		<span class="k">if</span> <span class="n">overall</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">betweeness</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">betweenness</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">edge_betweenness</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">edge_betweenness</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">degree</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">closeness</span>		  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">closeness</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">eigen</span> 			  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">shell_index</span>	  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">coreness</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">mem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">membership</span>
			<span class="n">evcen</span><span class="p">,</span><span class="n">btcen</span><span class="p">,</span><span class="n">clcen</span><span class="p">,</span><span class="n">degree</span><span class="p">,</span><span class="n">edge_bt</span><span class="p">,</span><span class="n">shell</span><span class="o">=</span><span class="p">[],[],[],[],[],[]</span>

			<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">mem</span><span class="p">:</span>
				<span class="n">sg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
				<span class="n">evcen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">eigenvector_centrality</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
				<span class="n">btcen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">betweenness</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="n">sg</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s">&#39;wts&#39;</span><span class="p">]))</span>
				<span class="n">clcen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">closeness</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
				<span class="n">degree</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>				
				<span class="n">edge_bt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">edge_betweenness</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
				<span class="n">shell</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">coreness</span><span class="p">())</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">betweeness</span>       <span class="o">=</span> <span class="n">btcen</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">edge_betweenness</span> <span class="o">=</span> <span class="n">edge_bt</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">degree</span>           <span class="o">=</span> <span class="n">degree</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">closeness</span>		  <span class="o">=</span> <span class="n">clcen</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">eigen</span> 			  <span class="o">=</span> <span class="n">evcen</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">shell_index</span>	  <span class="o">=</span> <span class="n">shell</span>

</div>
<div class="viewcode-block" id="GMgraph.Graph_Cluster"><a class="viewcode-back" href="../Doc.html#Moduler.GMgraph.Graph_Cluster">[docs]</a>	<span class="k">def</span> <span class="nf">Graph_Cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&#39;fastgreedy&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Clustering by components comstGreed, using igraph library.</span>
<span class="sd">		</span>
<span class="sd">		:param method: method in igraph ofr community detection. It can be fastgreedy, infomap leading_eigenvector_naive,leading_eigenvector,label_propagation, multilevel, optimal_modularity, edge_betweenness, spinglass, walktrap. For details see igraph documentation.</span>
<span class="sd">		:type method: string.</span>
<span class="sd">		:param kwargs: other arguments passed to the igraph methods</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ClusterMethod</span> <span class="o">=</span> <span class="n">method</span>
		<span class="n">memgreed</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c">#get independent componets of the graph</span>
		<span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">components</span><span class="p">()</span>
		<span class="k">print</span> <span class="s">&quot;There are </span><span class="si">%d</span><span class="s"> components in the network.&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
		<span class="c"># Check if only singletons</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">):</span>
			<span class="ne">Warning</span><span class="p">(</span><span class="s">&#39;Only singletons in the dataset&#39;</span><span class="p">)</span>
			<span class="n">mem</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">memgreed</span><span class="p">)):</span>
				<span class="n">memgreed</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c"># loop over each component and perform modularity optimization given the method provided</span>
			<span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">)):</span>
				<span class="n">cpn</span> <span class="o">=</span> <span class="n">comp</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpn</span><span class="o">.</span><span class="n">vs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">try</span><span class="p">:</span> <span class="n">mem</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cpn</span><span class="p">,</span><span class="s">&#39;community_&#39;</span><span class="o">+</span><span class="n">method</span><span class="p">)(</span><span class="n">cpn</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s">&#39;wts&#39;</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">as_clustering</span><span class="p">()</span>
					<span class="k">except</span><span class="p">:</span> <span class="n">mem</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cpn</span><span class="p">,</span><span class="s">&#39;community_&#39;</span><span class="o">+</span><span class="n">method</span><span class="p">)(</span><span class="n">cpn</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s">&#39;wts&#39;</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mem</span><span class="p">:</span>
						<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
							<span class="n">memgreed</span><span class="p">[</span><span class="n">cpn</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;label&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">index</span>
						<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">memgreed</span><span class="p">[</span><span class="n">comp</span><span class="p">[</span><span class="n">cp</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">index</span>
					<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">mem</span> <span class="o">=</span> <span class="n">memgreed</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">vertexclus</span> <span class="o">=</span> <span class="n">VertexClustering</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">membership</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertexclus</span><span class="o">.</span><span class="n">membership</span>
		<span class="k">try</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">modularityScore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s">&#39;wts&#39;</span><span class="p">])</span>
		<span class="k">except</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">modularityScore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">)</span>

		<span class="k">print</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s"> cluster(s) found.&quot;</span><span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">)))</span>
		<span class="k">print</span> <span class="s">&quot;Modularity score: </span><span class="si">%f</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modularityScore</span><span class="p">)</span>		

</div>
<div class="viewcode-block" id="GMgraph.Cluster2File"><a class="viewcode-back" href="../Doc.html#Moduler.GMgraph.Cluster2File">[docs]</a>	<span class="k">def</span> <span class="nf">Cluster2File</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; Write cluster to a file and rename the cluster with PDB friendly characters if possible (this is specific use)&#39;&#39;&#39;</span>
		<span class="n">chains</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;C&#39;</span><span class="p">,</span><span class="s">&#39;D&#39;</span><span class="p">,</span><span class="s">&#39;E&#39;</span><span class="p">,</span><span class="s">&#39;F&#39;</span><span class="p">,</span><span class="s">&#39;G&#39;</span><span class="p">,</span><span class="s">&#39;H&#39;</span><span class="p">,</span><span class="s">&#39;I&#39;</span><span class="p">,</span><span class="s">&#39;J&#39;</span><span class="p">,</span><span class="s">&#39;K&#39;</span><span class="p">,</span><span class="s">&#39;L&#39;</span><span class="p">,</span><span class="s">&#39;M&#39;</span><span class="p">,</span><span class="s">&#39;N&#39;</span><span class="p">,</span><span class="s">&#39;O&#39;</span><span class="p">,</span><span class="s">&#39;P&#39;</span><span class="p">,</span><span class="s">&#39;Q&#39;</span><span class="p">,</span><span class="s">&#39;R&#39;</span><span class="p">,</span><span class="s">&#39;S&#39;</span><span class="p">,</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="s">&#39;U&#39;</span><span class="p">,</span><span class="s">&#39;V&#39;</span><span class="p">,</span><span class="s">&#39;W&#39;</span><span class="p">,</span><span class="s">&#39;Y&#39;</span><span class="p">,</span><span class="s">&#39;Z&#39;</span><span class="p">,</span>
		          <span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="s">&#39;d&#39;</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;g&#39;</span><span class="p">,</span><span class="s">&#39;h&#39;</span><span class="p">,</span><span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="s">&#39;l&#39;</span><span class="p">,</span><span class="s">&#39;m&#39;</span><span class="p">,</span><span class="s">&#39;n&#39;</span><span class="p">,</span><span class="s">&#39;o&#39;</span><span class="p">,</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="s">&#39;q&#39;</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">,</span><span class="s">&#39;u&#39;</span><span class="p">,</span><span class="s">&#39;v&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">,</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="s">&#39;z&#39;</span><span class="p">,</span>
		          <span class="s">&#39;0&#39;</span><span class="p">,</span><span class="s">&#39;1&#39;</span><span class="p">,</span><span class="s">&#39;2&#39;</span><span class="p">,</span><span class="s">&#39;3&#39;</span><span class="p">,</span><span class="s">&#39;4&#39;</span><span class="p">,</span><span class="s">&#39;5&#39;</span><span class="p">,</span><span class="s">&#39;6&#39;</span><span class="p">,</span><span class="s">&#39;7&#39;</span><span class="p">,</span><span class="s">&#39;8&#39;</span><span class="p">,</span><span class="s">&#39;9&#39;</span><span class="p">]</span>
		<span class="n">line</span><span class="o">=</span><span class="s">&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">membership</span> <span class="p">,</span><span class="nb">str</span><span class="p">):</span> <span class="n">memb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">memb</span><span class="p">))</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">memb</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
					<span class="n">line</span> <span class="o">+=</span> <span class="n">chains</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">+</span><span class="s">&#39; &#39;</span>
				<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
					<span class="n">line</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&#39; &#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">memb</span><span class="p">:</span>
				<span class="n">line</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; &#39;</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.graphcluster&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
			<span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
		<span class="k">print</span> <span class="s">&#39;Membership vector found:&#39;</span>
		<span class="k">print</span> <span class="n">line</span>
		<span class="k">print</span> <span class="s">&#39;Membership vector written to </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.graphcluster&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">membership</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="GMgraph.Identify_Singletons"><a class="viewcode-back" href="../Doc.html#Moduler.GMgraph.Identify_Singletons">[docs]</a>	<span class="k">def</span> <span class="nf">Identify_Singletons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;fastgreedy&#39;</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; Given a membership vector identify singletons&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Graph_Cluster</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
		<span class="n">nc</span><span class="o">=</span><span class="s">&#39;&#39;</span>
		<span class="n">d</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">nc</span><span class="o">+=</span> <span class="s">&#39;? &#39;</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">nc</span><span class="o">+=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">membership</span> <span class="o">=</span> <span class="n">nc</span>
</div>
<div class="viewcode-block" id="GMgraph.LDAmerge"><a class="viewcode-back" href="../Doc.html#Moduler.GMgraph.LDAmerge">[docs]</a>	<span class="k">def</span> <span class="nf">LDAmerge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">which</span><span class="o">=</span><span class="s">&#39;lms&#39;</span><span class="p">,</span><span class="n">ellipses</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span><span class="n">dimensions</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Perform an LDA analisis and merge all classes which 95% confidence ellipses collide.</span>

<span class="sd">		:param which: Either &#39;gm&#39; or &#39;lms&#39;. To perform the LDA in the full matrix or only in the correlation matrix.</span>
<span class="sd">		:type which: string</span>
<span class="sd">		:param ellipses: A value representing the estandard deviations for confidence ellipses. By default is set to 2.5 (95% confidence ellipses)</span>
<span class="sd">		:type ellipses: float</span>
<span class="sd">		:param dimensions: dimensions of the matrix</span>
<span class="sd">		:type dimensions: integer</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmstats</span><span class="p">:</span>	
			<span class="bp">self</span><span class="o">.</span><span class="n">gmstats</span><span class="o">.</span><span class="n">LDA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span> <span class="n">ellipses</span><span class="o">=</span><span class="n">ellipses</span><span class="p">)</span>
			<span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gmstats</span><span class="o">.</span><span class="n">fit</span>
		<span class="k">else</span><span class="p">:</span> 
			<span class="n">stats</span> <span class="o">=</span> <span class="n">GMstats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
			<span class="n">fit</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">LDA</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="n">which</span><span class="p">,</span> <span class="n">ellipses</span><span class="o">=</span><span class="n">ellipses</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span>

		<span class="n">Ellipses</span> <span class="o">=</span> <span class="n">getEllipses</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">ellipses</span><span class="p">)</span>
		<span class="n">merges</span><span class="o">=</span><span class="p">[]</span>
		<span class="c">#Check for collisions between classes with 95% conficence ellipses</span>
		<span class="n">K</span><span class="o">=</span><span class="n">Ellipses</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ellipses</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Ellipses</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">EllipseOverlap</span><span class="p">(</span><span class="n">Ellipses</span><span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">Ellipses</span><span class="p">[</span><span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">]]):</span>
						<span class="n">merges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">K</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

		<span class="c">#merge unsupported clusters</span>
		<span class="n">newcl</span> <span class="o">=</span> <span class="n">equiclus</span><span class="p">(</span><span class="n">merges</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">newmem</span> <span class="o">=</span> <span class="n">rename_clusters</span><span class="p">(</span><span class="n">newcl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">membership</span><span class="p">)</span>	





<span class="c">###############################################################################################</span></div></div>
<div class="viewcode-block" id="SupportClustering"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering">[docs]</a><span class="k">class</span> <span class="nc">SupportClustering</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">	This class provides ways to provide statistical support for a given clustering scheme. It is based in</span>
<span class="sd">	testing if the correlation between groups is significatly different than  between groups.</span>

<span class="sd">	:param prefix: a prefix for the output.</span>
<span class="sd">	:type prefix: string</span>
<span class="sd">	:param data: a 2D numpy array with the data from which the clustering was inferred.</span>
<span class="sd">	:type data: :class `numpy.ndarray`</span>
<span class="sd">	:param membership: a list equal to the second dimension of data (i.e. data.shape[1]), corresponding to the clustering scheme being tested.</span>
<span class="sd">	:type membership: list</span>
<span class="sd">	:param dimensions: Number of dimensions in your data matrix. If your matrix is correlation or related, dimesions should be one.</span>
<span class="sd">	:type dimensions: integer</span>
<span class="sd">	:param permutations: Number of permutations to perform the permutation t-test.</span>
<span class="sd">	:type permutations: integer</span>
<span class="sd">	:param confval: confidence value for the test (1 - alpha).</span>
<span class="sd">	:type confval: float</span>
<span class="sd">	:param threshold: Value to filter out values of the correlation. If set to none, no threshold filtering will be done.</span>
<span class="sd">	:type threshold: float or None</span>
<span class="sd">	&#39;&#39;&#39;</span>	
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prefix</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">membership</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">confval</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">prefix</span>  <span class="o">=</span> <span class="n">prefix</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">GMdata</span><span class="p">):</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">data</span>   <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">GMdata</span> <span class="o">=</span> <span class="n">data</span>
		<span class="k">else</span><span class="p">:</span> 
			<span class="bp">self</span><span class="o">.</span><span class="n">data</span>   <span class="o">=</span> <span class="n">data</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">GMdata</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">confval</span> <span class="o">=</span> <span class="n">confval</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
		<span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">DealDimensions</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">dim</span>  <span class="o">=</span> <span class="n">dimensions</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">perm</span> <span class="o">=</span> <span class="n">permutations</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">thres</span><span class="o">=</span> <span class="n">threshold</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">mem</span>  <span class="o">=</span> <span class="n">membership</span>
		


<div class="viewcode-block" id="SupportClustering.DealDimensions"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.DealDimensions">[docs]</a>	<span class="k">def</span> <span class="nf">DealDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		If the data has more than one dimension (in the cartesian sense or the origin of the data),</span>
<span class="sd">		split it, compute correlation of each dimension and then aggregate it using euclidean distance</span>
<span class="sd">		of the coefficients of determination. It assumes that the dimensions are interleaved.</span>
<span class="sd">		This correlation does not have a significance testing, use caution.</span>
<span class="sd">		It is reccomended to use GMstats class before using this class.</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">dims</span><span class="o">=</span><span class="p">[]</span>
		<span class="n">Rs</span><span class="o">=</span><span class="mi">0</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
			<span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>

		<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
			<span class="n">C</span> <span class="o">=</span> <span class="n">corrcoef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">d</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
			<span class="n">Rs</span><span class="o">+=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">lms</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">Rs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SupportClustering.twotPermutation"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.twotPermutation">[docs]</a>	<span class="k">def</span> <span class="nf">twotPermutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This function computes the p-value for the two sample t-test using a permutation test.</span>
<span class="sd">		This is a translation from the DAAG Package function with the same name.</span>
<span class="sd">		:param x1: First array (sample) to be compared</span>
<span class="sd">		:type x1: :class `numpy.ndarray`</span>
<span class="sd">		:param x2: Second array (sample) to be compared</span>
<span class="sd">		:type x2: :class `numpy.ndarray`</span>
<span class="sd">		:param nsim: number of simulations to run ro compute the ovalue</span>
<span class="sd">		:type nsim: integer</span>
<span class="sd">		&#39;&#39;&#39;</span>	
		<span class="n">nsim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">perm</span>
		<span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
		<span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
		<span class="n">n</span>  <span class="o">=</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span>
		<span class="n">x</span>  <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">))</span>
		<span class="n">A</span>  <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
		<span class="n">s</span>  <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="n">dbar</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
		<span class="n">z</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">nsim</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nsim</span><span class="p">):</span>
			<span class="n">mn</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">n2</span><span class="p">)</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">mn</span><span class="p">]</span>
			<span class="n">wo</span><span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mn</span><span class="p">])))]</span>
			<span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="n">mean</span><span class="p">(</span><span class="n">wo</span><span class="p">)</span>
		<span class="n">pval</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">z</span> <span class="o">&gt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dbar</span><span class="p">))</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">dbar</span><span class="p">)))</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">nsim</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pval</span>		
</div>
<div class="viewcode-block" id="SupportClustering.subsetTest"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.subsetTest">[docs]</a>	<span class="k">def</span> <span class="nf">subsetTest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Given a series of indices, split the data into intra and inter correlation</span>
<span class="sd">		and test for equality</span>

<span class="sd">		:param subsetdata:</span>
<span class="sd">		:param k1: Name of one of the clusters being compared</span>
<span class="sd">		:type k1: string or integer</span>
<span class="sd">		:param k2: Name of the other clusters being compared</span>
<span class="sd">		:type k2: string or integer</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="c"># if threshold not required (i.e. threshold false or none) set to a really negative number</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">thres</span><span class="p">:</span> <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thres</span>
		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">thres</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span> <span class="n">threshold</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1e300</span>
		<span class="k">else</span><span class="p">:</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span>

		<span class="c"># get the indices of each group from lms</span>
		<span class="n">indA</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span> <span class="o">==</span> <span class="n">k1</span><span class="p">)</span>
		<span class="n">indB</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span> <span class="o">==</span> <span class="n">k2</span><span class="p">)</span>
		<span class="c"># get the elements corresponding to intragroups (A and B) and intergroups (AB)</span>
		<span class="c"># only the upper triangle</span>
		<span class="n">A</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">indA</span><span class="p">[</span><span class="mi">0</span><span class="p">],:][:,</span><span class="n">indA</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">triu_indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indA</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>
		<span class="n">B</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">indB</span><span class="p">[</span><span class="mi">0</span><span class="p">],:][:,</span><span class="n">indB</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">triu_indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indB</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>
		<span class="n">AB</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lms</span><span class="p">[</span><span class="n">indA</span><span class="p">[</span><span class="mi">0</span><span class="p">],:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
		<span class="c"># select cases above the threshold</span>
		<span class="n">A</span>    <span class="o">=</span>  <span class="n">A</span><span class="p">[</span><span class="n">where</span><span class="p">(</span><span class="n">A</span>  <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)]</span>
		<span class="n">B</span>    <span class="o">=</span>  <span class="n">B</span><span class="p">[</span><span class="n">where</span><span class="p">(</span><span class="n">B</span>  <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)]</span>
		<span class="n">AB</span>   <span class="o">=</span> <span class="n">AB</span><span class="p">[</span><span class="n">where</span><span class="p">(</span><span class="n">AB</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)]</span>
		<span class="c"># perform the permutation t-test</span>
		<span class="n">pvalA</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twotPermutation</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">AB</span><span class="p">)</span>
		<span class="n">pvalB</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twotPermutation</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">AB</span><span class="p">)</span>
		<span class="c"># store pvalues in their corresponding containers</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pvalA</span><span class="p">,</span><span class="n">pvalB</span><span class="p">])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cl</span><span class="p">[</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">vs</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span><span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">)]</span><span class="o">=</span> <span class="n">pvalA</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cl</span><span class="p">[</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">vs</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">k2</span><span class="p">,</span><span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">)]</span><span class="o">=</span> <span class="n">pvalB</span>
</div>
<div class="viewcode-block" id="SupportClustering.get_cluster_indices"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.get_cluster_indices">[docs]</a>	<span class="k">def</span> <span class="nf">get_cluster_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Returns a dictionary with cluster indices</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span> <span class="p">,</span><span class="nb">str</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span>
		<span class="n">d</span><span class="o">=</span><span class="p">{}</span>
		<span class="c"># get cluster indices</span>
		<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
			<span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
			<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">)):</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">==</span> <span class="n">l</span><span class="p">:</span>
					<span class="n">d</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="SupportClustering.filter_singletons"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.filter_singletons">[docs]</a>	<span class="k">def</span> <span class="nf">filter_singletons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">D</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Giving a dictionary with cluster indices, return whichones are singletons</span>

<span class="sd">		:param D: a dictionary with cluster indices</span>
<span class="sd">		:type D: dictionary</span>
<span class="sd">		:returns: a dictionary with the indices of unconnected nodes</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">singles</span><span class="o">=</span><span class="p">{}</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="n">C</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span>
		<span class="k">if</span> <span class="s">&#39;?&#39;</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
			<span class="c"># singletons already in membership vector</span>
			<span class="ne">Warning</span><span class="p">(</span><span class="s">&#39;Singletons might be already filtered. Check your results carefully&#39;</span><span class="p">)</span>

		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
			<span class="c"># if the count of the class is 1, is a singleton</span>
			<span class="k">if</span> <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">singles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;?&#39;</span>
		<span class="c">#Create a new membership vector replacing singletons by ?</span>
		<span class="n">newm</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">singles</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="n">newm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;?&#39;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span> <span class="n">newm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


		<span class="k">return</span> <span class="n">singles</span><span class="p">,</span> <span class="n">newm</span>
</div>
<div class="viewcode-block" id="SupportClustering.AreModneighbours"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.AreModneighbours">[docs]</a>	<span class="k">def</span> <span class="nf">AreModneighbours</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">indA</span><span class="p">,</span><span class="n">indB</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		loop over the adjacency matrix to find if indA and indB are in the neiborhood</span>

<span class="sd">		:param A: a list of tupples of related entries</span>
<span class="sd">		:type A: list</span>
<span class="sd">		:param indA: indices of grup A</span>
<span class="sd">		:type indA: list</span>
<span class="sd">		:param indB: indices of grup B</span>
<span class="sd">		:type indB: list</span>
<span class="sd">		:returns: boolean of whether or not indA and indB are neighbours</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">ans</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indA</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indB</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="n">ans</span> <span class="o">=</span> <span class="bp">True</span>
		<span class="k">return</span> <span class="n">ans</span>	
</div>
<div class="viewcode-block" id="SupportClustering.FDR_correction"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.FDR_correction">[docs]</a>	<span class="k">def</span> <span class="nf">FDR_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Compute the False Discovery Rate correction for the critical value</span>

<span class="sd">		&#39;&#39;&#39;</span>

		<span class="c">#sort and reverse the list for FDR correction</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">2</span><span class="p">:</span>
			<span class="n">FDR</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span><span class="p">):</span>
					<span class="n">FDR</span><span class="o">=</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">el</span><span class="p">)</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span><span class="p">)</span>
					<span class="k">break</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">continue</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">FDR</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">FDR</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="p">))</span>	

		<span class="bp">self</span><span class="o">.</span><span class="n">FDR</span><span class="o">=</span> <span class="n">FDR</span>
</div>
<div class="viewcode-block" id="SupportClustering.FDRc_sigtest"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.FDRc_sigtest">[docs]</a>	<span class="k">def</span> <span class="nf">FDRc_sigtest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Perform the logical significance test using FDR corrected critical value. Returns a binary</span>
<span class="sd">		dictionary of the comparisons</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="o">=</span><span class="p">{}</span>
		<span class="c"># loop over cl dictionary to write binary permt output into a dictionary</span>
		<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cl</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
			<span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDR</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>	

</div>
<div class="viewcode-block" id="SupportClustering.write_permt"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.write_permt">[docs]</a>	<span class="k">def</span> <span class="nf">write_permt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newm</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Write and print the output of the permutation test, the new membership vector, and do some </span>
<span class="sd">		cleanup</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="c"># Rename the previous graphcluster (the original of modularity)</span>
		<span class="c">#rename(self.prefix+&#39;.graphcluster&#39;,self.prefix+&#39;.%sold_graphcluster&#39;%(str(count)))</span>

		<span class="c"># Some lines of the output</span>
		<span class="n">line0</span><span class="o">=</span><span class="s">&#39;######## Significance test of Clustering  ########</span><span class="se">\n</span><span class="s">&#39;</span>
		<span class="n">line1</span><span class="o">=</span><span class="s">&#39;#&#39;</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="s">&#39; Test of Clustering (per_t-test)  &#39;</span> <span class="o">+</span> <span class="s">&#39;#&#39;</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
		<span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;#&#39;</span><span class="o">*</span><span class="mi">50</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
		<span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">line1</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>		
		<span class="n">FDRc</span><span class="o">=</span><span class="s">&#39;FDR-corrected Critical value = &#39;</span>
		<span class="k">print</span><span class="p">(</span><span class="n">FDRc</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FDR</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
		<span class="n">theader</span><span class="o">=</span><span class="s">&#39;Comparison</span><span class="se">\t</span><span class="s">p-value</span><span class="se">\t</span><span class="s">Significant?</span><span class="se">\n</span><span class="s">&#39;</span>
		<span class="k">print</span><span class="p">(</span><span class="n">theader</span><span class="p">)</span>		
		<span class="c"># Open the new graphcluster file and the permt output file</span>
		<span class="n">fname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.permt&#39;</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fout</span><span class="p">:</span>
			<span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">line1</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>
			<span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">FDRc</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FDR</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
			<span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">theader</span><span class="p">)</span>
			<span class="c"># Write the comparisons</span>
			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cl</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cl</span><span class="p">:</span>
					<span class="k">print</span> <span class="n">k</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
					<span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">cline</span><span class="o">=</span><span class="s">&#39;No adjacent clusters in the graph. Pvalue &lt; 10^-4 or singletons.&#39;</span>
				<span class="k">print</span> <span class="n">cline</span>
				<span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cline</span><span class="p">)</span>
			<span class="k">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
			<span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

		<span class="c"># Print and write the new membership vector</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newm</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>  <span class="n">newm</span><span class="o">=</span> <span class="n">newm</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="n">clustn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">newm</span><span class="p">))</span>
		<span class="k">if</span> <span class="s">&#39;?&#39;</span> <span class="ow">in</span> <span class="n">newm</span><span class="p">:</span>
			<span class="n">clustn</span> <span class="o">=</span> <span class="n">clustn</span><span class="o">-</span><span class="mi">1</span>
		<span class="k">print</span> <span class="nb">str</span><span class="p">(</span><span class="n">clustn</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; significant clusters&#39;</span>
		<span class="k">print</span> <span class="s">&#39;New membership vector:&#39;</span>
		<span class="n">newvec</span><span class="o">=</span><span class="s">&#39;&#39;</span>
		<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">newm</span><span class="p">:</span>
			<span class="n">newvec</span><span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="s">&#39; &#39;</span>
		<span class="k">print</span> <span class="n">newvec</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.graphcluster&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">clus</span><span class="p">:</span>
			<span class="n">clus</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">newvec</span><span class="p">)</span>	

		<span class="k">return</span> <span class="n">newvec</span>	
</div>
<div class="viewcode-block" id="SupportClustering.permt"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.permt">[docs]</a>	<span class="k">def</span> <span class="nf">permt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filterin</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Perform the permutation test over all pairs of classes in the membership vector provided</span>

<span class="sd">		:param filterin: a list of tuples of pairs of variable to be inlcuded (i.e. adjacency list if mem was provided by a graph)</span>
<span class="sd">		:type filterin: list</span>
<span class="sd">		:param count: Step in which this function has been called. Is for Iterative usage.</span>
<span class="sd">		:type count: string or integer</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="c">#provide containers for pvalues</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">pvals</span><span class="o">=</span><span class="p">[]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cl</span> <span class="o">=</span><span class="p">{}</span>
		<span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cluster_indices</span><span class="p">()</span>
		<span class="n">singles</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_singletons</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>		
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">singles</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">):</span>
			<span class="k">print</span><span class="p">(</span><span class="s">&#39;Only singletons in the dataset&#39;</span><span class="p">)</span>
			<span class="k">print</span><span class="p">(</span><span class="s">&#39;Bye Bye&#39;</span><span class="p">)</span>
			<span class="k">pass</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">print</span> <span class="s">&#39;Only one cluster. Bye, Bye&#39;</span>
			<span class="k">pass</span>
		<span class="c"># print progress to screen and read in the membership vector</span>
		<span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">+</span><span class="s">&#39; comparisons&#39;</span><span class="p">)</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&#39;Current membership vector:&#39;</span><span class="p">)</span>
		<span class="k">print</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&#39;Progress:&#39;</span><span class="p">)</span>		
		<span class="n">E</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
		<span class="k">if</span> <span class="s">&#39;?&#39;</span> <span class="ow">in</span> <span class="n">E</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="k">del</span> <span class="n">E</span><span class="p">[</span><span class="s">&#39;?&#39;</span><span class="p">]</span>
		<span class="n">keys</span><span class="o">=</span><span class="p">[]</span>	
		<span class="n">neighbours</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">E</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
			<span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
			<span class="n">indA</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">E</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
			<span class="k">for</span> <span class="n">ke</span><span class="p">,</span> <span class="n">va</span> <span class="ow">in</span> <span class="n">E</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">ke</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
					<span class="n">indB</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">E</span><span class="p">[</span><span class="n">ke</span><span class="p">]]</span>
					<span class="k">if</span> <span class="n">filterin</span><span class="p">:</span>
						<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AreModneighbours</span><span class="p">(</span><span class="n">filterin</span><span class="p">,</span><span class="n">indA</span><span class="p">,</span><span class="n">indB</span><span class="p">):</span>
							<span class="bp">self</span><span class="o">.</span><span class="n">subsetTest</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">ke</span><span class="p">)</span>
							<span class="n">neighbours</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">ke</span><span class="p">))</span>
						<span class="k">else</span><span class="p">:</span>
							<span class="k">continue</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="bp">self</span><span class="o">.</span><span class="n">subsetTest</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">ke</span><span class="p">)</span>
		<span class="c"># FDR correction</span>
		<span class="n">FDR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FDR_correction</span><span class="p">()</span>
		<span class="c"># Perform the logical comparisons using FDR-corrected critical value</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">FDRc_sigtest</span><span class="p">()</span>
		<span class="n">popkeys</span><span class="o">=</span><span class="p">{}</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;?&#39;</span><span class="p">:</span>
				<span class="n">popkeys</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">k</span>
		<span class="c"># Merge non-significant and reciprocal clusters</span>
		<span class="c"># Get the merging events </span>
		<span class="n">merg</span><span class="o">=</span><span class="p">[]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">filterin</span><span class="p">:</span>
			<span class="n">ncls</span><span class="o">=</span><span class="p">[]</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
				<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">D</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="n">j</span> <span class="o">==</span> <span class="s">&#39;?&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">k</span> <span class="o">==</span> <span class="s">&#39;?&#39;</span><span class="p">:</span>
						<span class="k">try</span><span class="p">:</span>
							<span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">ord</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
								<span class="n">ncls</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">))</span>
						<span class="k">except</span><span class="p">:</span>
							<span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">:</span>
								<span class="n">ncls</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ncls</span> <span class="o">=</span> <span class="n">neighbours</span>
		<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ncls</span><span class="p">:</span>
			<span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="o">=</span> <span class="n">l</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="p">[</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">vs</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">popkeys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">popkeys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">popkeys</span><span class="p">[</span><span class="n">e</span><span class="p">])]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="p">[</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">vs</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">popkeys</span><span class="p">[</span><span class="n">e</span><span class="p">],</span><span class="n">popkeys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
				                                                                                     <span class="n">popkeys</span><span class="p">[</span><span class="n">e</span><span class="p">])]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
					<span class="n">merg</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">))</span>		
			<span class="k">except</span><span class="p">:</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="p">[</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">vs</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">popkeys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">popkeys</span><span class="p">[</span><span class="n">e</span><span class="p">],</span><span class="n">popkeys</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">scl</span><span class="p">[</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">vs</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">popkeys</span><span class="p">[</span><span class="n">e</span><span class="p">],</span><span class="n">popkeys</span><span class="p">[</span><span class="n">e</span><span class="p">],</span>
							                                                                         <span class="n">popkeys</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
					<span class="n">merg</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">))</span>						
		<span class="c"># List of sets of equivalent clusters</span>
		<span class="n">newcl</span> <span class="o">=</span> <span class="n">equiclus</span><span class="p">(</span><span class="n">merg</span><span class="p">)</span>
		<span class="c"># Rename clusters using the smallest label in each set</span>
		<span class="n">newm</span> <span class="o">=</span> <span class="n">rename_clusters</span><span class="p">(</span><span class="n">newcl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span>		
		<span class="c">#open Outfile and write result</span>
		<span class="n">newvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_permt</span><span class="p">(</span><span class="n">newm</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">mem</span> <span class="o">=</span> <span class="n">newm</span>
		<span class="k">return</span> <span class="n">newm</span><span class="p">,</span> <span class="n">newvec</span>
</div>
<div class="viewcode-block" id="SupportClustering.VectorToEdgeList"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.VectorToEdgeList">[docs]</a>	<span class="k">def</span> <span class="nf">VectorToEdgeList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		Convert a membership vector to a list of edges.</span>
<span class="sd">		The membership vector must be a list or space separated string.</span>

<span class="sd">		:param v: a membership vector in list form</span>
<span class="sd">		:type v: list</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

		<span class="c"># Output vector</span>
		<span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="c"># Process edges only once (no symmetry)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
					<span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>

		<span class="c"># return edge list</span>
		<span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="SupportClustering.iterative_permt"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.iterative_permt">[docs]</a>	<span class="k">def</span> <span class="nf">iterative_permt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filterin</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Perform a permutation test iteratively, until a stable membership vector is reached. In each iteration</span>
<span class="sd">		a permutation test is performed between the clusters, and a merge event will happen if no evidence of</span>
<span class="sd">		difference is found.</span>

<span class="sd">		:param filterin: a list of tuples of pairs of variable to be inlcuded (i.e. adjacency list if mem was provided by a graph)</span>
<span class="sd">		:type filterin: list</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">memvec</span><span class="o">=</span><span class="p">[</span><span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">)]</span>
		<span class="n">count</span><span class="o">=</span><span class="mi">0</span>
		
		<span class="k">while</span> <span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
			<span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
			<span class="n">it</span><span class="o">=</span> <span class="s">&#39;Performing iteration number </span><span class="si">%d</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
			<span class="k">print</span> <span class="s">&#39;</span><span class="se">\n\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)),</span><span class="n">it</span><span class="p">,</span><span class="s">&#39;*&#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">it</span><span class="p">)))</span>
			<span class="n">newm</span><span class="p">,</span> <span class="n">newvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">permt</span><span class="p">(</span><span class="n">filterin</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>
			<span class="n">memvec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newm</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">memvec</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
				<span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">VectorToEdgeList</span><span class="p">(</span><span class="n">memvec</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
				<span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">VectorToEdgeList</span><span class="p">(</span><span class="n">memvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">fsc</span> <span class="o">=</span> <span class="n">Fscore</span><span class="p">(</span><span class="n">Specificity</span><span class="p">(</span><span class="n">old</span><span class="p">,</span><span class="n">new</span><span class="p">),</span> <span class="n">Sensitivity</span><span class="p">(</span><span class="n">old</span><span class="p">,</span><span class="n">new</span><span class="p">))</span>
				<span class="k">if</span> <span class="n">fsc</span> <span class="o">&gt;=</span> <span class="mf">0.9999</span><span class="p">:</span>
					<span class="k">break</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">mem</span> <span class="o">=</span> <span class="n">newm</span>
		<span class="k">return</span> <span class="n">newm</span><span class="p">,</span> <span class="n">newvec</span>
</div>
<div class="viewcode-block" id="SupportClustering.if_bootfile"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.if_bootfile">[docs]</a>	<span class="k">def</span> <span class="nf">if_bootfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boot</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		if another bootsrap intance has been called and crashed, this function will finished</span>
<span class="sd">		the remaining and / or compute the agreement</span>

<span class="sd">		:param boot: Number of bootstrap replicates to be performed</span>
<span class="sd">		:type boot: integer</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">vectors</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.bootstrap&#39;</span><span class="p">):</span>
			<span class="k">print</span> <span class="s">&#39;Previous bootstrap run found. Using </span><span class="si">%s</span><span class="s"> file&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.bootstrap&#39;</span><span class="p">)</span>
			<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.bootstrap&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="s">&#39;&#39;</span> <span class="ow">or</span> <span class="n">e</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">:</span>
						<span class="k">continue</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">m</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;[&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;]&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;&quot;&#39;</span><span class="p">,</span><span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;&#39;&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
						<span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>                
			<span class="n">dif</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">boot</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">dif</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="c"># reopen boot file and keep going</span>
				<span class="n">F</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.bootstrap&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">F</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">),</span><span class="n">boot</span><span class="p">),</span> <span class="n">vectors</span>
			<span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="p">[],</span> <span class="n">vectors</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.bootstrap&#39;</span><span class="p">,</span><span class="s">&#39;a&#39;</span><span class="p">),</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">),</span><span class="n">boot</span><span class="p">),</span> <span class="n">vectors</span>
</div>
<div class="viewcode-block" id="SupportClustering.bootstrap"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.bootstrap">[docs]</a>	<span class="k">def</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">boot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">contacts</span><span class="o">=</span><span class="p">[],</span><span class="n">unweighted</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">graphmethod</span><span class="o">=</span><span class="s">&#39;fastgreedy&#39;</span><span class="p">,</span> <span class="n">lda</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
	              <span class="n">iterative</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;	</span>
<span class="sd">		Execute the bootstrap inferfence. This boostrap resample obsevations (rows) in the data</span>

<span class="sd">		:param boot: Number of bootstrap replicates to be performed</span>
<span class="sd">		:type boot: integer</span>
<span class="sd">		:param contacts: filter out non-contact interactions. Contacts passed as list of tuples</span>
<span class="sd">		:type contacts: list</span>
<span class="sd">		:param unweighted: create an unweighted graph as opposed to a weighted (correlation; default) one.</span>
<span class="sd">		:type unweighted: boolean</span>
<span class="sd">		:param graphmethod: method in igraph ofr community detection. It can be fastgreedy, infomap leading_eigenvector_naive,leading_eigenvector,label_propagation, multilevel, optimal_modularity, edge_betweenness, spinglass, walktrap. For details see igraph documentation.</span>
<span class="sd">		:type method: string.</span>
<span class="sd">		:param lda:	Use LDA to premerge the community detection clusters</span>
<span class="sd">		:type lda: boolean</span>
<span class="sd">		:param kwargs: parameter and arguments for GMstats class in the method Compute_correlations</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">bout</span><span class="p">,</span> <span class="n">Range</span><span class="p">,</span> <span class="n">vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">if_bootfile</span><span class="p">(</span><span class="n">boot</span><span class="o">=</span><span class="n">boot</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">Range</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootvectors</span> <span class="o">=</span> <span class="n">vectors</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">GMdata</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">GMdata</span> <span class="o">=</span> <span class="n">GMdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span><span class="n">dimension</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
		<span class="c">#backup data</span>
		<span class="c">#F = glob(prefix+&#39;*&#39;)</span>
		<span class="c">#for f in F:</span>
		<span class="c">#	# get the extension and filename</span>
		<span class="c">#	ext = f[f.rfind(&#39;.&#39;):]</span>
		<span class="c">#	name = f[:f.find(ext)]</span>
		<span class="c">#	nf=name+&#39;_original&#39;+ext</span>
		<span class="c">#	# rename the file</span>
		<span class="c">#	rename(f,nf)</span>
		
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Range</span><span class="p">:</span>
			<span class="n">bootprefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;_boot</span><span class="si">%d</span><span class="s">&#39;</span><span class="o">%</span><span class="n">i</span>
			<span class="n">l</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">#  BOOTSTRAP REPLICATE </span><span class="si">%d</span><span class="s">  #</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="k">print</span> <span class="s">&#39;#&#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="n">l</span><span class="p">,</span><span class="s">&#39;#&#39;</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GMdata</span><span class="o">.</span><span class="n">bootstrap_replicate</span><span class="p">()</span>
			<span class="n">BootStats</span> <span class="o">=</span> <span class="n">GMstats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">BootStats</span><span class="o">.</span><span class="n">Compute_correlations</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
			<span class="k">if</span> <span class="s">&#39;additive&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">BootStats</span><span class="o">.</span><span class="n">agglomerare_additive</span><span class="p">()</span>
			<span class="k">else</span><span class="p">:</span> <span class="n">BootStats</span><span class="o">.</span><span class="n">agglomerare_mean</span><span class="p">()</span>

			<span class="n">BootGraph</span> <span class="o">=</span> <span class="n">GMgraph</span><span class="p">(</span><span class="n">bootprefix</span><span class="p">,</span> <span class="n">BootStats</span><span class="p">,</span> <span class="n">unweighted</span><span class="o">=</span><span class="n">unweighted</span><span class="p">,</span> <span class="n">gfilter</span><span class="o">=</span><span class="n">contacts</span><span class="p">,</span>
			                    <span class="n">threshold</span><span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;threshold&#39;</span><span class="p">])</span>
			<span class="k">if</span> <span class="n">contacts</span><span class="p">:</span>
				<span class="n">filterin</span> <span class="o">=</span> <span class="n">GMgr</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">get_adjacency</span><span class="p">()</span> <span class="c"># get the adjacency matrix to filter permt</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">filterin</span> <span class="o">=</span> <span class="p">[]</span>				

			<span class="n">BootGraph</span><span class="o">.</span><span class="n">Identify_Singletons</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">graphmethod</span><span class="p">)</span><span class="c">#Graph_Cluster(method=graphmethod)</span>
			<span class="n">mem</span> <span class="o">=</span> <span class="n">BootGraph</span><span class="o">.</span><span class="n">membership</span>
			<span class="k">if</span> <span class="n">lda</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">contacts</span><span class="p">:</span>
					<span class="k">print</span> <span class="s">&#39;WARNING!! Using Linear discriminant pre-filtering without contacts &#39;</span>\
					      <span class="s">&#39;will underestimate the number of modules!! Use the non lda filtered option instead.&#39;</span>
				<span class="k">print</span> <span class="s">&#39;Membership vector before LDA (singletons are labelled as ?):&#39;</span>
				<span class="k">print</span> <span class="n">mem</span>
				<span class="n">BootGraph</span><span class="o">.</span><span class="n">LDAmerge</span><span class="p">()</span>
				<span class="n">mem</span> <span class="o">=</span> <span class="n">BootGraph</span><span class="o">.</span><span class="n">newmem</span>
				<span class="k">print</span> <span class="s">&#39;Membership vector after LDA:&#39;</span>
				<span class="k">print</span> <span class="n">mem</span>

			<span class="n">BootSigClust</span> <span class="o">=</span> <span class="n">SupportClustering</span><span class="p">(</span><span class="n">bootprefix</span><span class="p">,</span> <span class="n">BootStats</span><span class="o">.</span><span class="n">lms</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="p">,</span> <span class="n">confval</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">confval</span><span class="p">,</span> 
			                                 <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">thres</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">iterative</span><span class="p">:</span>
				<span class="n">BootSigClust</span><span class="o">.</span><span class="n">iterative_permt</span><span class="p">(</span><span class="n">filterin</span><span class="p">)</span>
			<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">perm</span><span class="p">:</span>
				<span class="n">newm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">BootSigClust</span><span class="o">.</span><span class="n">permt</span><span class="p">(</span><span class="n">filterin</span><span class="p">)</span>
				<span class="n">BootSigClust</span><span class="o">.</span><span class="n">mem</span> <span class="o">=</span> <span class="n">newm</span>
			<span class="n">bout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Boot </span><span class="si">%d</span><span class="s">#</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">BootSigClust</span><span class="o">.</span><span class="n">mem</span><span class="p">))</span>
			<span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BootSigClust</span><span class="o">.</span><span class="n">mem</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">bootvectors</span> <span class="o">=</span> <span class="n">vectors</span>

		<span class="c">#edges = [self.VectorToEdgeList(v) for v in vectors]</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">bipartition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_agreement</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">WriteBoot</span><span class="p">()</span>
		</div>
<div class="viewcode-block" id="SupportClustering.bipartition_agreement"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.bipartition_agreement">[docs]</a>	<span class="k">def</span> <span class="nf">bipartition_agreement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">		Calculate the local bipartition agreement scores</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootvectors</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> <span class="n">refvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span> <span class="n">refvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mem</span>
		<span class="n">clusters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">refvec</span><span class="p">)))</span>
		<span class="n">refbipartitions</span> <span class="o">=</span> <span class="p">{}</span> <span class="c">## dictionary containing each cluster&#39;s bipartition</span>
		<span class="k">for</span> <span class="n">clus</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
			<span class="n">refbipartitions</span><span class="p">[</span><span class="n">clus</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">refvec</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">refvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">clus</span><span class="p">:</span>
					<span class="n">refbipartitions</span><span class="p">[</span><span class="n">clus</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39;1&#39;</span> <span class="c">## 1 for dot</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">refbipartitions</span><span class="p">[</span><span class="n">clus</span><span class="p">]</span> <span class="o">+=</span> <span class="s">&#39;0&#39;</span> <span class="c">## 0 for dash</span>
	
		<span class="c"># Enumerate all the bipartitions in the replicate set</span>
		<span class="n">repbipartitions</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">)):</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span> <span class="n">repvec</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
			<span class="k">else</span><span class="p">:</span> <span class="n">repvec</span><span class="o">=</span><span class="n">vectors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="n">cluses</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">repvec</span><span class="p">)))</span>
			<span class="k">for</span> <span class="n">clus</span> <span class="ow">in</span> <span class="n">cluses</span><span class="p">:</span>
				<span class="n">partition</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">repvec</span><span class="p">)):</span>
					<span class="k">if</span> <span class="n">repvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">clus</span><span class="p">:</span>
						<span class="n">partition</span> <span class="o">+=</span> <span class="s">&#39;1&#39;</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">partition</span> <span class="o">+=</span> <span class="s">&#39;0&#39;</span>
				<span class="k">if</span> <span class="n">partition</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">repbipartitions</span><span class="p">:</span>
					<span class="n">repbipartitions</span><span class="p">[</span><span class="n">partition</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">repbipartitions</span><span class="p">[</span><span class="n">partition</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
	
		<span class="c"># Calculate the score</span>
		<span class="n">FOUT</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.scores.bootstrap&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
		<span class="n">bipartitions</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">repbipartitions</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="c">## total number of bipartitions in the replicate set</span>
		<span class="k">for</span> <span class="n">clus</span> <span class="ow">in</span> <span class="n">refbipartitions</span><span class="p">:</span>
			<span class="n">agreement</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">repbipartitions</span><span class="p">:</span>
				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BipartitionAgree</span><span class="p">(</span><span class="n">refbipartitions</span><span class="p">[</span><span class="n">clus</span><span class="p">],</span> <span class="n">p</span><span class="p">):</span>
					<span class="n">agreement</span> <span class="o">+=</span> <span class="n">repbipartitions</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
			<span class="n">bipartitions</span><span class="p">[</span><span class="n">clus</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">agreement</span><span class="p">)</span><span class="o">/</span><span class="n">total</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	
		<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">bipartitions</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
			<span class="n">FOUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\t</span><span class="si">%f</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
	
		<span class="n">FOUT</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
		<span class="k">return</span> <span class="n">bipartitions</span>	
	
	</div>
<div class="viewcode-block" id="SupportClustering.BipartitionAgree"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.BipartitionAgree">[docs]</a>	<span class="k">def</span> <span class="nf">BipartitionAgree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Return whether 2 strings of bipartitions agree or conflict. The strings must consist of</span>
<span class="sd">		1 and 0 only</span>
<span class="sd">		</span>
<span class="sd">		:params a,b: binary bipartition strings to be compared for agreements.</span>
<span class="sd">		:type a,b: strings</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&#39; and &#39;</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="s">&#39; are not of the same length to compare bipartitions.&#39;</span><span class="p">)</span>
			
		<span class="k">else</span><span class="p">:</span>
			<span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
					<span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span>	
		</div>
<div class="viewcode-block" id="SupportClustering.WriteBoot"><a class="viewcode-back" href="../Doc.html#Moduler.SupportClustering.WriteBoot">[docs]</a>	<span class="k">def</span> <span class="nf">WriteBoot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Write Bootstrap results to screen and file</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="n">line</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">Bootstrap results</span><span class="se">\n</span><span class="s">&#39;</span>
		<span class="n">line</span> <span class="o">=</span> <span class="s">&#39;*&#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">+</span><span class="n">line</span><span class="o">+</span><span class="s">&#39;*&#39;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
			<span class="n">line</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> = </span><span class="si">%f</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bipartition</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.bipartitions&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">F</span><span class="p">:</span> <span class="n">F</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
		<span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
		
<span class="c"># Auxiliary methods</span></div></div>
<div class="viewcode-block" id="isFloat"><a class="viewcode-back" href="../Doc.html#Moduler.isFloat">[docs]</a><span class="k">def</span> <span class="nf">isFloat</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Auxiliary function to test if a string is a float</span>
<span class="sd">	</span>
<span class="sd">	:param str string: The string to be tested</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="nb">float</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">True</span>
	<span class="k">except</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>

	</div>
<div class="viewcode-block" id="rename_clusters"><a class="viewcode-back" href="../Doc.html#Moduler.rename_clusters">[docs]</a><span class="k">def</span> <span class="nf">rename_clusters</span><span class="p">(</span><span class="n">newcl</span><span class="p">,</span> <span class="n">mem</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Rename clusters using the smallest label in each set. Returns the new</span>
<span class="sd">	membership vector</span>

<span class="sd">	:param newcl: a list with the new membership before renaming</span>
<span class="sd">	:type newcl: list</span>
<span class="sd">	:param mem: original membership vector</span>
<span class="sd">	:type mem: list</span>
<span class="sd">	:returns: A list with the renamed vector</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">babel</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">newcl</span><span class="p">:</span>
		<span class="n">newname</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cluster</span><span class="p">:</span>
			<span class="n">babel</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">newname</span>

	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mem</span><span class="p">)):</span>
		<span class="k">if</span> <span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">babel</span><span class="p">:</span>
			<span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">babel</span><span class="p">[</span><span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>		

	<span class="c"># Create the new membership vector</span>
	<span class="n">newm</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">ite</span> <span class="ow">in</span> <span class="n">mem</span><span class="p">:</span>
		<span class="n">newm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ite</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">newm</span>		
</div>
<div class="viewcode-block" id="equiclus"><a class="viewcode-back" href="../Doc.html#Moduler.equiclus">[docs]</a><span class="k">def</span> <span class="nf">equiclus</span><span class="p">(</span><span class="n">merge</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Look for equivalent clusters, and return a list with sets of equivalent clusters</span>

<span class="sd">	:param merge: list of tuples with the pairs of classes to be merged</span>
<span class="sd">	:type merge: list</span>
<span class="sd">	:returns: cleaned membership vector as a list</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="c"># List of sets of equivalent clusters</span>
	<span class="n">newcl</span> <span class="o">=</span> <span class="p">[]</span>	
	<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">merge</span><span class="p">:</span>
		<span class="n">m</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">merged</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="c"># look for a newcl item which overlaps then merge</span>
		<span class="k">for</span> <span class="n">nc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newcl</span><span class="p">)):</span>
			<span class="n">xnc</span> <span class="o">=</span> <span class="n">newcl</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">xnc</span><span class="p">):</span>
				<span class="c"># Merge into xnc</span>
				<span class="n">newcl</span><span class="p">[</span><span class="n">nc</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnc</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
				<span class="n">merged</span> <span class="o">=</span> <span class="bp">True</span>
				<span class="k">break</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">merged</span><span class="p">:</span>
			<span class="c"># New cluster to add to newcl</span>
			<span class="n">newcl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">newcl</span>
</div>
<div class="viewcode-block" id="ellipse"><a class="viewcode-back" href="../Doc.html#Moduler.ellipse">[docs]</a><span class="k">def</span> <span class="nf">ellipse</span><span class="p">(</span><span class="n">singlegroupx</span><span class="p">,</span><span class="n">singlegroupy</span><span class="p">,</span><span class="n">std</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">	Create an ellipse given points with x coordinates in singlegroupx and singlegroupy</span>
<span class="sd">	</span>
<span class="sd">	:param singlegroupx: An array with the x coordinates of data for what the ellipse is to be built.</span>
<span class="sd">	:type singlegroupx: :class `numpy.array`</span>
<span class="sd">	:param singlegroupy: An array with the y coordinates of data for what the ellipse is to be built.</span>
<span class="sd">	:type singlegroupy: :class `numpy.array`</span>
<span class="sd">	:param std: The standard deviation of the confidence ellipse. By default is set to 2.5 (95% confidence ellipse)</span>
<span class="sd">	:type std: float</span>
<span class="sd">	:returns: a :class `matplotlib.patches.Ellipse` object</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">covar</span>     <span class="o">=</span> <span class="n">cov</span><span class="p">(</span><span class="n">singlegroupx</span><span class="p">,</span> <span class="n">singlegroupy</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">isnan</span><span class="p">(</span><span class="n">covar</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
		<span class="n">width</span> <span class="o">=</span> <span class="mf">0.01</span>
		<span class="n">height</span><span class="o">=</span> <span class="mf">0.01</span>
		<span class="n">angle</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">lambda_</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">covar</span><span class="p">)</span>
		<span class="n">lambda_</span>    <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">lambda_</span><span class="p">)</span>
		<span class="n">width</span>      <span class="o">=</span> <span class="n">lambda_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">std</span><span class="o">*</span><span class="mi">2</span>
		<span class="n">height</span>     <span class="o">=</span> <span class="n">lambda_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">std</span><span class="o">*</span><span class="mi">2</span>
		<span class="n">angle</span>      <span class="o">=</span> <span class="n">rad2deg</span><span class="p">(</span><span class="n">arccos</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>

	<span class="n">centerx</span>    <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">singlegroupx</span><span class="p">)</span>
	<span class="n">centery</span>    <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">singlegroupy</span><span class="p">)</span>		
	<span class="n">ell</span>        <span class="o">=</span> <span class="n">Ellipse</span><span class="p">(</span><span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">centerx</span><span class="p">,</span><span class="n">centery</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span> <span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span> <span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">ell</span>
</div>
<div class="viewcode-block" id="pointsInEllipse"><a class="viewcode-back" href="../Doc.html#Moduler.pointsInEllipse">[docs]</a><span class="k">def</span> <span class="nf">pointsInEllipse</span><span class="p">(</span><span class="n">Xs</span><span class="p">,</span><span class="n">Ys</span><span class="p">,</span><span class="n">ellipse</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Tests which set of points are within the boundaries defined by the ellipse. The set of points</span>
<span class="sd">	are defined in two arrays Xs and Ys for the x-coordinates and y-coordinates respectively.</span>
<span class="sd">	</span>
<span class="sd">	:params Xs: x-coordinates of a set of points</span>
<span class="sd">	:type Xs: :class `numpy.array` or list</span>
<span class="sd">	:params Ys: y-coordinates of a set of points</span>
<span class="sd">	:type Ys: :class `numpy.array` or list</span>
<span class="sd">	:param ellipse: instance of method ellipse</span>
<span class="sd">	:type ellipse: :class `matplotlib.patches.Ellipse`</span>
<span class="sd">	:returns: Tuple of two list, points inside and outside of the ellipse</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">inside</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">outside</span><span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Xs</span><span class="p">)):</span>
		<span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="n">Xs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">Ys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
		<span class="k">if</span> <span class="n">ellipse</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
			<span class="n">inside</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">outside</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">inside</span><span class="p">,</span> <span class="n">outside</span>
</div>
<div class="viewcode-block" id="getEllipses"><a class="viewcode-back" href="../Doc.html#Moduler.getEllipses">[docs]</a><span class="k">def</span> <span class="nf">getEllipses</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">membership</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Populate the ellipses dictionary with as many ellipses as components in membership.</span>

<span class="sd">	:param fit: An array normally computed by LDA or other method</span>
<span class="sd">	:type fit: :class `numpy.array`</span>
<span class="sd">	:param std: The standard deviation of the confidence ellipse. By default is set to 2.5 (95% confidence ellipse)</span>
<span class="sd">	:type std: float</span>
<span class="sd">	:param membership: A list corresponding to memberships of the entries in data.</span>
<span class="sd">	:type membership: list</span>
<span class="sd">	:returns: A dictionary with Ellipse objects with membership as keys.</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">ellipses</span><span class="o">=</span><span class="p">{}</span>
	<span class="k">for</span> <span class="n">mem</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">membership</span><span class="p">)):</span>
		<span class="n">sub</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="n">where</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">membership</span><span class="p">)</span> <span class="o">==</span> <span class="n">mem</span><span class="p">)]</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">sub</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">Xs</span><span class="o">=</span><span class="n">sub</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">Ys</span><span class="o">=</span><span class="n">sub</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">ellipses</span><span class="p">[</span><span class="n">mem</span><span class="p">]</span><span class="o">=</span><span class="n">ellipse</span><span class="p">(</span><span class="n">Xs</span><span class="p">,</span><span class="n">Ys</span><span class="p">,</span><span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">ellipses</span>
</div>
<div class="viewcode-block" id="EllipseOverlap"><a class="viewcode-back" href="../Doc.html#Moduler.EllipseOverlap">[docs]</a><span class="k">def</span> <span class="nf">EllipseOverlap</span><span class="p">(</span><span class="n">ellipse1</span><span class="p">,</span><span class="n">ellipse2</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">	Find collisions between ellipses</span>
<span class="sd">	</span>
<span class="sd">	:param ellipse1: Matplotlib ellipse</span>
<span class="sd">	:type ellipse1: :class `matplotlib.patches.Ellipse`</span>
<span class="sd">	:param ellipse2: Matplotlib ellipse</span>
<span class="sd">	:type ellipse2: :class `matplotlib.patches.Ellipse`</span>
<span class="sd">	:returns: Boolean of whether or not two ellipses collide</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">pointsin2</span><span class="o">=</span><span class="n">ellipse2</span><span class="o">.</span><span class="n">properties</span><span class="p">()[</span><span class="s">&#39;verts&#39;</span><span class="p">]</span>
	<span class="n">ins</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">pointsInEllipse</span><span class="p">(</span><span class="n">pointsin2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pointsin2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">ellipse1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ins</span><span class="p">):</span> <span class="k">return</span> <span class="bp">True</span>
	<span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>



</div>
<div class="viewcode-block" id="Specificity"><a class="viewcode-back" href="../Doc.html#Moduler.Specificity">[docs]</a><span class="k">def</span> <span class="nf">Specificity</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Compute specificity from two edgelists (list of edges between nodes/labes)</span>

<span class="sd">	:param ref: Reference edgelist </span>
<span class="sd">	:type ref: list</span>
<span class="sd">	:param test: Test edgelist</span>
<span class="sd">	:type test: list</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c"># Size of intersection</span>
	<span class="n">A</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>

	<span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Sensitivity"><a class="viewcode-back" href="../Doc.html#Moduler.Sensitivity">[docs]</a><span class="k">def</span> <span class="nf">Sensitivity</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Compute sensitivity from two edgelists (list of edges between nodes/labes)</span>

<span class="sd">	:param ref: Reference edgelist</span>
<span class="sd">	:type ref: list</span>
<span class="sd">	:param test: Test edgelist</span>
<span class="sd">	:type test: list</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c"># Size of intersection</span>
	<span class="n">A</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">test</span><span class="p">))</span>

	<span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Fscore"><a class="viewcode-back" href="../Doc.html#Moduler.Fscore">[docs]</a><span class="k">def</span> <span class="nf">Fscore</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">sn</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">	Compute the F-score </span>

<span class="sd">	:param sp: Specificity value</span>
<span class="sd">	:type sp: float</span>
<span class="sd">	:param sn: Sensitivity value</span>
<span class="sd">	:type sn: float</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">sp</span><span class="o">*</span><span class="n">sn</span><span class="o">/</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="n">sn</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="clus2list"><a class="viewcode-back" href="../Doc.html#Moduler.clus2list">[docs]</a><span class="k">def</span> <span class="nf">clus2list</span><span class="p">(</span><span class="n">membership</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Giving a membership vector and data, split the data into cluster specific arrays.</span>

<span class="sd">	:param membership: a membership vector</span>
<span class="sd">	:type membership: list or string</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">membership</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span> <span class="n">m</span> <span class="o">=</span> <span class="n">membership</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
	<span class="k">else</span><span class="p">:</span> <span class="n">m</span> <span class="o">=</span> <span class="n">membership</span>
	<span class="c">#dictionary to hold the array corresponding to each cluster</span>
	<span class="n">darr</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">smem</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">smem</span><span class="p">:</span>
		<span class="n">ind</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="o">==</span> <span class="s">&#39;?&#39;</span><span class="p">:</span>	
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
				<span class="n">temp</span><span class="o">=</span><span class="p">[]</span>
				<span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
					<span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">ind</span><span class="p">,:][:,</span><span class="n">ind</span><span class="p">][</span><span class="n">triu_indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))])</span>
				<span class="n">darr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">darr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="p">,:][:,</span><span class="n">ind</span><span class="p">][</span><span class="n">triu_indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))]</span>
				<span class="k">else</span><span class="p">:</span> <span class="n">darr</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span><span class="n">ind</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">darr</span>

<span class="c"># Moduler specific methods... execution</span></div>
<span class="k">def</span> <span class="nf">_Master_of_ceremony</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">contacts</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">additive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;fisher&#39;</span><span class="p">,</span><span class="n">absolutecov</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                       <span class="n">confval</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">usecov</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">writemat</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">overall</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">lda</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">perm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">iterative</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                       <span class="n">power</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span><span class="n">mapmodules</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">morph</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">boot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">graphmethod</span><span class="o">=</span><span class="s">&#39;fastgreedy&#39;</span><span class="p">):</span>
	<span class="c"># Say hi!!!#######################################################################</span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Welcome to MODULER version </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">__version__</span><span class="p">))</span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;A python script to explore modularity on coordinates data</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="p">)</span>
	<span class="n">l</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
	<span class="c"># Print the chosen parameters and write it to a file #########################</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Chosen parameters:</span><span class="se">\n</span><span class="s">&#39;</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Test of significance for correlation = </span><span class="si">%s</span><span class="se">\n</span><span class="s">Power analysis = </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">method</span><span class="p">,</span><span class="n">power</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Aglomerate dimensions as Euclidean distance = </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">additive</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Confidence Value = </span><span class="si">%f</span><span class="s"> (to be use in both correlation and significance test if true)</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">confval</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Write matrices to file: </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">writemat</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Absolute value of correlation = </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">absolutecov</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Dimensions = </span><span class="si">%d</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">perm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">l</span><span class="o">+=</span><span class="s">&#39;Single test for significance of clusters = True with </span><span class="si">%d</span><span class="s"> permutations</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">l</span><span class="o">+=</span><span class="s">&#39;Single test for significance of clusters = False</span><span class="se">\n</span><span class="s">&#39;</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Iterative test for significance of clusters = </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">iterative</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Filtering out non contact interactions = </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">contacts</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Linear discriminants prefiltering = </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">lda</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Bootstrap : </span><span class="si">%d</span><span class="s"> (if 0 no bootstrap is performed)</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">boot</span><span class="p">)</span>
	<span class="n">l</span><span class="o">+=</span> <span class="s">&#39;Optimization method for modularity in the graph: </span><span class="si">%s</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">graphmethod</span><span class="p">)</span>
	<span class="c">#l+= &#39;Analyse  interlandmark distances (if False will use raw coordinates) = %s&#39;%(options.dist)</span>
	<span class="k">print</span> <span class="n">l</span>
	<span class="n">ou</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.parameters&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span> 
	<span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
	<span class="n">ou</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;file created on </span><span class="si">%s</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">now</span><span class="p">))</span><span class="o">+</span><span class="n">l</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">ou</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">contacts</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">additive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;fisher&#39;</span><span class="p">,</span> <span class="n">confval</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">absolutecov</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
         <span class="n">usecov</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">graphmethod</span><span class="o">=</span><span class="s">&#39;fastgreedy&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">writemat</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">overall</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">lda</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">perm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">iterative</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
         <span class="n">mapmodules</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">morph</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">boot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">unweighted</span><span class="o">=</span><span class="bp">False</span> <span class="p">):</span>
	<span class="sd">&#39;&#39;&#39; </span>
<span class="sd">	Execute the code Moduler as __main__</span>

<span class="sd">	:param prefix: Prefix of your GM file and accompanying files. Also will be use for output files</span>
<span class="sd">	:type prefix: string</span>
<span class="sd">	:param dimensions: The number of cartesian dimensions to be analyzed. By default is set to 3.</span>
<span class="sd">	:type dimensions: integer</span>
<span class="sd">	:param contacts: Constrain the graph to only things that are in contact. If True it will look for a file with &#39;.contact&#39; extension.If the file cannot be found it will look for a PDB file named &lt;prefix&gt;.pdb, and will try to compute the contacts from :class PDBstructure. If the pdb cannot be found it will raise an exception.</span>
<span class="sd">	:type contacts: boolean</span>
<span class="sd">	:param additive: Use the mean of the correlation in each dimension instead of the euclidean distance to aglomerate the dimensions. The default behaviour is additive.</span>
<span class="sd">	:type additive: boolean</span>
<span class="sd">	:param method: Which method to use for correlation. By default it uses the fisher transformation. Available options are pearson, spearman and fisher.        </span>
<span class="sd">	:type method: string</span>
<span class="sd">	:param confval: Define the confidence level (1-alpha) for the correlation test. By default is 0.95. Can take any float value between 0 and 1.</span>
<span class="sd">	:type confval: float</span>
<span class="sd">	:param power: Perform a statistical power analysis with this value as the desired Power (1-type II error). by default 0.8 is used. Can be any float from 0 to 1</span>
<span class="sd">	:type power: float</span>
<span class="sd">	:param absolutecov: Whether or not to use absolute values of the correlation matrix</span>
<span class="sd">	:type absolutecov: boolean</span>
<span class="sd">	:param usecov: Use covariance instead of correlation</span>
<span class="sd">	:type usecov: boolean</span>
<span class="sd">	:param graphmethod: Method to seach for the partition of the graph. By default is fastgreedy. Refer to igraph documentation in community method for other options.</span>
<span class="sd">	:type graphmethod: string</span>
<span class="sd">	:param threshold: A float corresponding to the threshold to create a conection between nodes. This is very user dependendent and is set to 0 as default.</span>
<span class="sd">	:type threshold: float</span>
<span class="sd">	:param writemat: Write correlation/covariance matrices to file. By default is false. It can take a False, for the aggreatated matrix or cor for the correlation matrix.</span>
<span class="sd">	:type writemat: boolean</span>
<span class="sd">	:param overall: Calculate the centralities on the full graph, as opposed as by modules (Default behaviour).</span>
<span class="sd">	:type overall: boolean</span>
<span class="sd">	:param lda:	Use LDA to premerge the community detection clusters</span>
<span class="sd">	:type lda: boolean</span>
<span class="sd">	:param perm: number of permutation for the significance tests</span>
<span class="sd">	:type perm: integer</span>
<span class="sd">	:param iterative: whether to perform significance test among clusters iteratevely until estabilization of the cluster.</span>
<span class="sd">	:type iterative: boolean</span>
<span class="sd">	:param mapmodules: Map the Modules in a PDB provided. The PDB and chain in which to map, have to be provided comma separated.</span>
<span class="sd">	:type mapmodules: string</span>
<span class="sd">	:param morph: Use this if you want to estimate the modularity of morphological data. Basically it will create a dummy landmark file.</span>
<span class="sd">	:type morph: boolean</span>
<span class="sd">	:param boot: Compute bootstrap for sample reliability estimation</span>
<span class="sd">	:param mc: a file handle from Master_of_Ceremony mathod.</span>
<span class="sd">	:type mc: opened file</span>
<span class="sd">	:param unweighted: create an unweighted graph as opposed to a weighted (correlation; default) one.</span>
<span class="sd">	:type unweighted: boolean</span>
<span class="sd">	&#39;&#39;&#39;</span> 
	<span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;method&#39;</span><span class="p">:</span><span class="n">method</span><span class="p">,</span> <span class="s">&#39;absolutecov&#39;</span><span class="p">:</span><span class="n">absolutecov</span><span class="p">,</span> <span class="s">&quot;confval&quot;</span><span class="p">:</span><span class="n">confval</span><span class="p">,</span> <span class="s">&#39;usecov&#39;</span><span class="p">:</span><span class="n">usecov</span><span class="p">,</span>
	        <span class="s">&#39;writemat&#39;</span><span class="p">:</span><span class="n">writemat</span><span class="p">,</span> <span class="s">&#39;additive&#39;</span><span class="p">:</span><span class="n">additive</span><span class="p">,</span> <span class="s">&#39;power&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">,</span> <span class="s">&#39;threshold&#39;</span><span class="p">:</span> <span class="n">threshold</span><span class="p">}</span>
	<span class="c"># instantiate Data #####################################################</span>
	<span class="n">GMd</span> <span class="o">=</span> <span class="n">GMdata</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span><span class="n">dimension</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span><span class="n">contacts</span><span class="o">=</span><span class="n">contacts</span><span class="p">)</span>
	<span class="c"># Load Contacts ########################################################</span>
	<span class="n">gfilter</span> <span class="o">=</span> <span class="n">GMd</span><span class="o">.</span><span class="n">contacts</span>
	<span class="c"># do the stats</span>
	<span class="n">GMs</span> <span class="o">=</span> <span class="n">GMstats</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">GMd</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span><span class="n">sample_size</span><span class="o">=</span><span class="n">GMd</span><span class="o">.</span><span class="n">sample_size</span><span class="p">)</span>

	<span class="n">GMs</span><span class="o">.</span><span class="n">Compute_correlations</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">absolutecov</span><span class="o">=</span><span class="n">absolutecov</span><span class="p">,</span> <span class="n">confval</span><span class="o">=</span><span class="n">confval</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> 
	                         <span class="n">usecov</span><span class="o">=</span><span class="n">usecov</span><span class="p">,</span> <span class="n">writemat</span><span class="o">=</span><span class="n">writemat</span><span class="p">,</span> <span class="n">additive</span><span class="o">=</span><span class="n">additive</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="n">power</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">additive</span><span class="p">:</span> <span class="n">GMs</span><span class="o">.</span><span class="n">agglomerare_additive</span><span class="p">()</span>
	<span class="k">else</span><span class="p">:</span> <span class="n">GMs</span><span class="o">.</span><span class="n">agglomerare_mean</span>

	<span class="c"># get Edge assignment threshold and print it to screen #################</span>
	<span class="k">if</span> <span class="n">threshold</span> <span class="o">==</span> <span class="s">&#39;Auto&#39;</span><span class="p">:</span> 
		<span class="n">GMs</span><span class="o">.</span><span class="n">GetAglomeratedThreshold</span><span class="p">()</span>
	<span class="k">elif</span> <span class="n">mc</span><span class="p">:</span>
		<span class="n">t</span> <span class="o">=</span> <span class="s">&#39;Threshold mode: Custom = </span><span class="si">%f</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
		<span class="n">mc</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>	
		<span class="k">print</span> <span class="n">t</span>

	<span class="c"># Build igraph ###################################################################</span>
	<span class="n">GMgr</span> <span class="o">=</span> <span class="n">GMgraph</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">GMs</span><span class="p">,</span> <span class="n">unweighted</span><span class="o">=</span><span class="n">unweighted</span><span class="p">,</span> <span class="n">gfilter</span><span class="o">=</span><span class="n">gfilter</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">contacts</span><span class="p">:</span>
		<span class="n">filterin</span> <span class="o">=</span> <span class="n">GMgr</span><span class="o">.</span><span class="n">g</span><span class="o">.</span><span class="n">get_adjacency</span><span class="p">()</span> <span class="c"># get the adjacency matrix to filter permt</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">filterin</span> <span class="o">=</span> <span class="p">[]</span>

	<span class="c"># Clustering by components comstGreed ############################################</span>
	<span class="n">GMgr</span><span class="o">.</span><span class="n">Identify_Singletons</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">graphmethod</span><span class="p">)</span>
	<span class="c">#memgreed = GMgr.mem</span>
	<span class="n">mem</span> <span class="o">=</span> <span class="n">GMgr</span><span class="o">.</span><span class="n">membership</span>

	<span class="c"># write to cluster file ##########################################################</span>
	<span class="n">GMgr</span><span class="o">.</span><span class="n">Cluster2File</span><span class="p">()</span>

	<span class="c"># run LDA to premerge clusters</span>
	<span class="k">if</span> <span class="n">lda</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">contacts</span><span class="p">:</span>
			<span class="k">print</span> <span class="s">&#39;WARNING!! Using Linear discriminant pre-filtering without contacts &#39;</span>\
			      <span class="s">&#39;will underestimate the number of modules!! Use the non lda filtered option instead.&#39;</span>
		<span class="k">print</span> <span class="s">&#39;Membership vector before LDA (singletons are labelled as ?):&#39;</span>
		<span class="k">print</span> <span class="n">mem</span>
		<span class="n">GMgr</span><span class="o">.</span><span class="n">LDAmerge</span><span class="p">()</span>
		<span class="n">mem</span> <span class="o">=</span> <span class="n">GMgr</span><span class="o">.</span><span class="n">newmem</span>
		<span class="k">print</span> <span class="s">&#39;Membership vector after LDA:&#39;</span>
		<span class="k">print</span> <span class="n">mem</span>
	<span class="c"># significance test of clustering: Outputs a new graphcluster</span>
	<span class="n">SigClust</span> <span class="o">=</span> <span class="n">SupportClustering</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">GMs</span><span class="o">.</span><span class="n">lms</span><span class="p">,</span> <span class="n">mem</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">confval</span><span class="o">=</span><span class="n">confval</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">iterative</span><span class="p">:</span>
		<span class="n">SigClust</span><span class="o">.</span><span class="n">iterative_permt</span><span class="p">(</span><span class="n">filterin</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">perm</span><span class="p">:</span>
		<span class="n">newm</span><span class="p">,</span> <span class="n">newvec</span> <span class="o">=</span> <span class="n">SigClust</span><span class="o">.</span><span class="n">permt</span><span class="p">(</span><span class="n">filterin</span><span class="p">)</span>
		<span class="n">SigClust</span><span class="o">.</span><span class="n">mem</span> <span class="o">=</span> <span class="n">newm</span>

	<span class="c"># Perform options.power analyses</span>
	<span class="k">if</span> <span class="n">power</span><span class="p">:</span>
		<span class="n">propor</span> <span class="o">=</span> <span class="n">GMs</span><span class="o">.</span><span class="n">Clus_Power</span><span class="p">(</span><span class="n">mem</span><span class="p">)</span>


	<span class="k">if</span> <span class="n">boot</span><span class="p">:</span>
		<span class="n">SigClust</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">(</span><span class="n">boot</span><span class="o">=</span><span class="n">boot</span><span class="p">,</span><span class="n">contacts</span><span class="o">=</span><span class="n">filterin</span><span class="p">,</span><span class="n">unweighted</span><span class="o">=</span><span class="n">unweighted</span><span class="p">,</span> <span class="n">graphmethod</span><span class="o">=</span><span class="n">graphmethod</span><span class="p">,</span><span class="o">**</span><span class="n">args</span><span class="p">)</span>
	<span class="c"># Map modules and centralities #########################################################</span>
	<span class="k">if</span> <span class="n">mapmodules</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">GMd</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">istrajectory</span><span class="p">:</span>
			<span class="n">names</span> <span class="o">=</span> <span class="n">GMd</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">GetModelNames</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">names</span> <span class="o">=</span> <span class="n">GMd</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">GetChainNames</span><span class="p">()</span>
		<span class="n">GMd</span><span class="o">.</span><span class="n">pdb</span><span class="o">.</span><span class="n">Map2Protein</span><span class="p">(</span><span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.mapped.pdb&#39;</span><span class="p">,</span> <span class="n">SigClust</span><span class="o">.</span><span class="n">mem</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prefix</span><span class="o">+</span><span class="s">&#39;.fasta&#39;</span><span class="p">)</span>


<span class="c"># End of definitions###########################################################################</span>

<span class="c"># Aplication of the code ######################################################################</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
	<span class="c"># Command line input #############################################################</span>
	<span class="n">opts</span> <span class="o">=</span> <span class="n">optparse</span><span class="o">.</span><span class="n">OptionParser</span><span class="p">(</span><span class="n">usage</span><span class="o">=</span><span class="s">&#39;%prog &lt;prefix&gt; [options]&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-o&#39;</span><span class="p">,</span><span class="s">&#39;--covariance&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;usecov&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&quot;store_true&quot;</span><span class="p">,</span>
	                <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Use covariance instead of correlation to build the graph. If this option is not </span>
<span class="s">	                provided the program will use correlation by default.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-a&#39;</span><span class="p">,</span><span class="s">&#39;--mean&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;additive&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&quot;store_false&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Use the mean of the correlation in each dimension instead of the euclidean distance to aglomerate</span>
<span class="s">	                the dimensions. The default behaviour is additive.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-t&#39;</span><span class="p">,</span> <span class="s">&#39;--threshold&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;threshold&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span><span class="c"># type=float, </span>
	                <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span> <span class="s">&#39;&#39;&#39;Set the threshold for edge assingment to the value provided. Otherwise is set to 0. </span>
<span class="s">	                An extra option is Auto which will calculate the treshold based on the mean standard deviation of the </span>
<span class="s">	                agglomerated dimensions matrix.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-p&#39;</span><span class="p">,</span><span class="s">&#39;--power&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;power&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;float&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Perform a power analysis with this value as the desired Power (1-type II error). Default: 0.8&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-m&#39;</span><span class="p">,</span><span class="s">&#39;--method&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;method&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;fisher&#39;</span><span class="p">,</span> 
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Test the significance of the correlation by the method provided(pearson, spearman, </span>
<span class="s">	                kendall or fisher). The latter is the fisher transformation of the pearson correlation. If no test</span>
<span class="s">	                needed False should be provided.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-i&#39;</span><span class="p">,</span> <span class="s">&#39;--confidencelevel&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;confval&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;float&#39;</span><span class="p">,</span>
	                <span class="n">default</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Define the confidence level (1-alpha) for the correlation test. </span>
<span class="s">	                Default: 0.95.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-d&#39;</span><span class="p">,</span><span class="s">&#39;--dimensions&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s">&#39;dimensions&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Set the dimensions of the shape. Default: 3.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-c&#39;</span><span class="p">,</span><span class="s">&#39;--contact&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;contacts&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Use the all-atom contact matrix when assigning edges. Default: False.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-u&#39;</span><span class="p">,</span><span class="s">&#39;--absolute&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;absolutecov&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">&quot;store_true&quot;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span> <span class="s">&#39;&#39;&#39;Use absolute values of the correlation matrix. Default: False.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-n&#39;</span><span class="p">,</span> <span class="s">&#39;--permtest&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;perm&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Test the significance of clustering with N permutations. When 0 is passed, no permutation</span>
<span class="s">	                test is performed.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-I&#39;</span><span class="p">,</span><span class="s">&#39;--iterative&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;iterative&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_false&#39;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span> <span class="s">&#39;&#39;&#39;Iterative (until convergence) test the significance of clustering with permutations </span>
<span class="s">	                being passed through permtest. &#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-w&#39;</span><span class="p">,</span><span class="s">&#39;--matrix&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;writemat&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> 
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Write to file the matrix of the option chosen. It can be either cor (which will print</span>
<span class="s">	                the correlation matrix for each dimension), or agg will write to a file the </span>
<span class="s">	                agglomerated dimensions matrix.&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="c">#opts.add_option(&#39;-r&#39;,&#39;--RV&#39;,dest=&#39;rv&#39;,action=&quot;store_false&quot;,default=True,</span>
	<span class="c">#               help=&#39;Do not Write the the Excouffier RV for the modules inferred.&#39;\</span>
	<span class="c">#              &#39; The p-values will be given using the Pearson type III approximation.&#39;)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-f&#39;</span><span class="p">,</span><span class="s">&#39;--fullcentrality&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;overall&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">&quot;store&quot;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Use this if you want to calculate the centralities on the full graph, as opposed as by</span>
<span class="s">		            modules ( Default behaviour ).&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-B&#39;</span><span class="p">,</span><span class="s">&#39;--bootstrap&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;boot&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;int&#39;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Compute bootstrap for sample reliability estimation.&#39;&#39;&#39;</span><span class="p">)</span>	
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-l&#39;</span><span class="p">,</span><span class="s">&#39;--lda&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;lda&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">&quot;store_true&quot;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Use LDA to premerge the community detection clusters&#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-G&#39;</span><span class="p">,</span><span class="s">&#39;--graph&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;graphmethod&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">&quot;store&quot;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="s">&#39;fastgreedy&#39;</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Use one of igraph methods for community detection inference. By default is fastgreedy</span>
<span class="s">	                but it can take: infomap, leading_eigenvector_naive, leading_eigenvector, label_propagation, </span>
<span class="s">	                multilevel, optimal_modularity, edge_betweenness, spinglass, walktrap. For details see igraph</span>
<span class="s">	                documentation. &#39;&#39;&#39;</span><span class="p">)</span>
	<span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s">&#39;-C&#39;</span><span class="p">,</span><span class="s">&#39;--mapmodules&#39;</span><span class="p">,</span><span class="n">dest</span><span class="o">=</span><span class="s">&#39;mapmodules&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s">&quot;store&quot;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
	                <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Map the Modules in the PDB provided. The PDB and chain in which to map, have to be provided</span>
<span class="s">                    comma separated. IT ONLY WORKS ON PROTEIN STRUCTURES&#39;&#39;&#39;</span><span class="p">)</span>  
	<span class="n">options</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
	
	<span class="n">prefix</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="c"># Introduce the program and write parameters to a file and screen ################</span>
	<span class="n">mc</span> <span class="o">=</span> <span class="n">Master_of_ceremony</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span><span class="o">**</span><span class="nb">vars</span><span class="p">(</span><span class="n">options</span><span class="p">))</span>
	<span class="n">options</span><span class="o">.</span><span class="n">_update_loose</span><span class="p">({</span><span class="s">&#39;mc&#39;</span><span class="p">:</span><span class="n">mc</span><span class="p">})</span><span class="c">#include mc in the options</span>
	<span class="c">#execute</span>
	<span class="n">main</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span><span class="o">**</span><span class="nb">vars</span><span class="p">(</span><span class="n">options</span><span class="p">))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Jose Sergio Hleap.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
    </div>

    

    
  </body>
</html>